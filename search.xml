<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[为 hexo-next 增加搜索功能]]></title>
    <url>%2F2018%2F10%2F30%2F2018-2018-10-30-hexo-add-local-search%2F</url>
    <content type="text"><![CDATA[为 hexo - next 增加搜索功能，方便快速定位 源自链接 https://segmentfault.com/a/1190000010881874 用自带的插件实现安装 hexo-generator-search12npm install hexo-generator-search --save 安装 hexo-generator-searchdb1npm install hexo-generator-searchdb --save 启用搜索修改hexo配置文件，在根目录下的_config.yml中增加如下配置：12345search: path: search.xml field: post format: html limit: 10000 配置next中的搜索入口打开themes\next_config.yml，将local_search.enable 设为true 123# Local searchlocal_search: enable: true 运行测试一下1hexo s]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win7 安装vagrant]]></title>
    <url>%2F2018%2F10%2F29%2F2018-2018-10-29-win7-install-vagrant%2F</url>
    <content type="text"><![CDATA[win7 安装vagrant，做为开发环境，但有时会出错。现将之记录下来。 安装回头补，主要是遇到的错误要先记下来 已知错误powershell 版本太低 错误信息： The version of powershell currently installed on this host is less than the required minimum version. Please upgrade the installed version of powershell to the minimum required version and run the command again. Installed version: 2 Minimum required version: 3 解决方法 # 参见微软官网 https://social.technet.microsoft.com/wiki/contents/articles/21016.how-to-install-windows-powershell-4-0.aspx 但是，由于win7估计快被微软放弃了，不能装了。于是stackoverflow了一下。 https://stackoverflow.com/questions/19902239/how-to-upgrade-powershell-version-from-2-0-to-3-0 Install Chocolatey ## 打开cmd,在 cmd中写入以下命令 @&quot;%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot; Run the following commands in CMD choco install powershell choco upgrade powershell restart your computer]]></content>
      <tags>
        <tag>develop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic3 gps]]></title>
    <url>%2F2018%2F08%2F01%2F2018-2018-08-01-ionic3-gps%2F</url>
    <content type="text"><![CDATA[做一个ionic3版的GPS定位，我主要是参考ionic官网的简单例子来做的，不足请指教。 1：运行命令：来安装GPS插件 ionic cordova plugin add cordova-plugin-geolocation npm install --save @ionic-native/geolocation 2: 晕，好久生成的，都忘了，后面补起]]></content>
  </entry>
  <entry>
    <title><![CDATA[整理win7下载地址]]></title>
    <url>%2F2018%2F07%2F02%2F2018-2018-07-02-windows7-iso-ed2k%2F</url>
    <content type="text"><![CDATA[整理几个win7的系统下载地址，都是vol版，方便以后安装 512企业版X86cn_windows_7_enterprise_with_sp1_x86_dvd_u_677716.iso (2.33 GB) 512企业版X64cn_windows_7_enterprise_with_sp1_x64_dvd_u_677685.iso (3.04 GB) 512专业版X86cn_windows_7_professional_with_sp1_vl_build_x86_dvd_u_677939.iso (2.33 GB) 512专业版X64cn_windows_7_professional_with_sp1_vl_build_x64_dvd_u_677816.iso (3.04 GB)]]></content>
      <categories>
        <category>reprint</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jekyll panxw blog]]></title>
    <url>%2F2018%2F06%2F28%2F2018-2018-06-28-jekyll-panxw-blog%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 准备把blog 改成这个 panxw 的模板，现在写一下改的过程 官方bloghttps://www.panxw.com/ 源码地址https://github.com/panxw/panxw.github.com 用法参见官网 改动下面说一下我使用中的改动 修改配置文件修改 _config.yml#permalink节点 #我的习惯年月 日就算了，毕竟一天不可能一天几篇 permalink: /:categories/:year/:month/:title # 然后这几个 人个配置信息 github: uljjmhn520 author: &quot;lopy&quot; email: xxxx#163.com name: &quot;lopy&apos;s Blog&quot; baseurl: / url: http://blog.lopy.win domain: blog.lopy.win # 分类，暂时不管，以后按自己的情况修改 all_categories: [ [&quot;android&quot;, &quot;Android开发&quot;,&quot;/android/index.html&quot;], [&quot;react&quot;, &quot;React Native&quot;, &quot;/react/index.html&quot;], [&quot;web&quot;, &quot;Web建站&quot;,&quot;/web/index.html&quot;], [&quot;linux&quot;, &quot;Linux相关&quot;,&quot;/linux/index.html&quot;], [&quot;git&quot;, &quot;git用法&quot;,&quot;/git/index.html&quot;], [&quot;program&quot;, &quot;软件开发&quot;,&quot;/program/index.html&quot;], [&quot;vps&quot;, &quot;VPS&quot;,&quot;/vps/index.html&quot;], [&quot;other&quot;, &quot;杂记&quot;,&quot;/other/index.html&quot;], [&quot;read&quot;, &quot;书摘&quot;,&quot;/read/index.html&quot;], [&quot;about&quot;, &quot;关于&quot;,&quot;/about.html&quot;] ] # 加入节点 friendly_links ，将友链写入配置文件 friendly_links: [ [&quot;GitHub&quot;,&quot;https://github.com&quot;], [&quot;baidu&quot;,&quot;https://www.baidu.com&quot;], ] 修改部分源码加入 Rakefile这个提取自 jekyll-bootstrap 然后稍微改了几句和post 相关的，其他的没有改完。 改 index.html&lt;span class=&quot;glyphicon glyphicon-time&quot;&gt;&lt;/span&gt; { { post.date | date:&quot;%F %T&quot; }} &lt;/div&gt; 改 _layouts/post.html日期：{ { page.date | date:&quot;%F %T&quot; }}&amp;nbsp;&amp;nbsp;&amp;nbsp; 修改友链页面## 改成从配置文件中获取 friendlinks.html &lt;ul class=&quot;list-unstyled&quot;&gt; { % for link in site.friendly_links %} &lt;li&gt; &lt;a href=&quot;{ {link[1]}}&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt; { {link[0]}} &lt;/a&gt; &lt;/li&gt; { % endfor %} &lt;/ul&gt; 新增友链按钮&lt;div class=&quot;linkme&quot;&gt; &lt;a href=&quot;http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=w7SqraWqsa6DsrLtoKyu&quot; target=&quot;_blank&quot;&gt; &lt;span class=&quot;linkme_span&quot;&gt;交换链接 暂不改1&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[winserver 2003 r2 sp2 vol 企业版]]></title>
    <url>%2F2018%2F05%2F30%2F2018-2018-05-30-winserver-2003-r2-sp2-vol-enterprise%2F</url>
    <content type="text"><![CDATA[有的时候会用winserver2003 做服务器，还是记下一个吧 Windows 2003 R2 SP2 VOL 企业版（简体中文） 下载链接32位版CD1:SHA1值:d0dd2782e9387328ebfa45d8804b6850acabf520 ed2k://|file|cn_win_srv_2003_r2_enterprise_with_sp2_vl_cd1_X13-46432.iso|637917184|284dc0e76945125035b9208b9199e465|h=EH6ISTIVFR5627ONBBNBKELX4VYGJPAW|/ CD2:SHA1值:4b364e848fcc59762dddced1493248e2896ee033 ed2k://|file|cn_win_srv_2003_r2_enterprise_with_sp2_vl_cd2.iso|129703936|512c89a5839ffc8a3f3124acb9e9cb75|h=TJQXAYJUDXXM7E5X64KQBL56OUKTLU5E| 序列号：MDGJK-PF6YQ-PD8DJ-RFQVM-7WKWG 64位版：CD1:HASH:FDA1A0401CA610F6E3A7780D6DB004DA2F944138 ed2k://|file|cn_win_srv_2003_r2_enterprise_x64_with_sp2_vl_cd1_X13-47314.iso|647686144|107F10D2A7FF12FFF0602FF60602BB37|/ CD2:HASH:42CB2508F37B7B3331B8EB7A04D58DB508248821 ed2k://|file|cn_win_srv_2003_r2_enterprise_x64_with_sp2_vl_cd2_X13-35321.iso|179204096|651EDB26E33E1AD0F14430245D4D44C6|/ 序列号RYCR6-T7Y6M-2TVHK-C2YW3-7TYQ8]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debian9 安装 lnmp]]></title>
    <url>%2F2018%2F05%2F17%2F2018-2018-05-17-debian9-lnmp%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 apt-get update apt-get install nginx mysql-server php7.0-fpm php7.0-curl php7.0-gd php7.0-intl php-pear php7.0-imagick php7.0-imap php7.0-mcrypt php7.0-common php7.0-mysql php7.0-pspell php7.0-recode php7.0-sqlite php7.0-tidy php7.0-xmlrpc php7.0-xsl php7.0-memcached memcached]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>debian</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vbox中debian9安装增强功能和文件共享]]></title>
    <url>%2F2018%2F05%2F17%2F2018-2018-05-17-debian9-install-vboxadditions%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 安装先安装以下apt update apt upgrade apt install build-essential module-assistant dkms reboot 然后安装 VBoxAdditions 在vbox 进入debian系统 然后 Devices &gt; Insert Guest Additions CD image. 然后，在系统中挂载VBoxAdditions光盘镜像 mount /media/cdrom 安装插件 sh /media/cdrom/VBoxLinuxAdditions.run reboot 设置共享文件夹 设置》共享文件夹》 新建 选择路径， 设置名称，比如 vbox_sharing 勾选 自动挂载和固定分配，点确定 后面补图 设置开机自动挂载到到指定点前面设置好共享文件夹后，系统启动时，会挂载到 /media/sf_&lt;挂载名称&gt;，如 /media/sf_vbox_sharing 现在，我们要设置自动挂载到指定点，就是修改 /etc/fstab 挂载命令的格式为，挂载之前 path 应该存在， &lt; &gt; 中间的值可变 &lt;sharing name&gt; &lt;path&gt; vboxsf &lt;options&gt; 0 0如 mkdir /var/vbox_sharing vbox_sharing /var/vbox_sharing vboxsf comment=systemd.automount 0 0 然后保存，重启，不出意外就成功了 其中，option 中可有很多参数 到时给个链接，现在没时间去找 其中 comment=systemd.automount 参数没有，貌似就不会成功 还有其它的，比如指定用户组 gid=1000,uid=1000 如: vbox_sharing /var/vbox_sharing vboxsf gid=1000,uid=1000,comment=systemd.automount 0 0 引用https://www.linuxbabe.com/debian/install-virtualbox-guest-additions-debian-9-stretch https://askubuntu.com/questions/365346/virtualbox-shared-folder-mount-from-fstab-fails-works-once-bootup-is-complete]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>debian</tag>
        <tag>virtualbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic hot update]]></title>
    <url>%2F2017%2F12%2F01%2F2017-2017-12-01-ionic-hot-update%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 ionic3 热更新学习1.安装基本框架npm install -g ionic@latest npm install -g cordova ionic 2.新建ionic项目ionic start myapp 3.进入项目文件夹# 执行下面命令可以预览项目 cd myapp # 正常显示后可以关掉服务Ctrl+C，此步骤只是保证ionic新建项目成功 ionic serve 4.ios目前已不支持热更新，所以只对Android平台进行设置# 设置Android平台 ionic cordova platform add android # 设置安卓版本需修改下面两个文件内容的target的值，默认设好了 platforms/android/project.properties platforms/android/CordovaLib/project.properties # 安装热更新插件 cordova plugin add cordova-hot-code-push-plugin cordova plugin add cordova-hot-code-push-local-dev-addon npm install -g cordova-hot-code-push-cli 5.在config.xml配置文件中加入下面节点&lt;chcp&gt; &lt;config-file url=&quot;http://192.168.1.203:8121/chcp.json&quot; /&gt; &lt;native-interface version=&quot;1&quot; /&gt; &lt;/chcp&gt; # 第一个子节点是需要发布在iis上的文件地址 # 第二个子节点是当前版本号 # 还有其它配置此处不再罗列 6.新开一个终端执行下面命令cordova-hcp server 如果能够正常输出类似 Running server Checking: /ionic/myapp/www/ local_url http://localhost:31284 Warning: .chcpignore does not exist. Build 2017.10.27-10.17.48 created in ionic/myapp/www cordova-hcp local server available at: http://localhost:31284 cordova-hcp public server available at: https://5027caf9.ngrok.com 检查/项目名称/www 路径下 有chcp.json和chcp.manifest表示热更新服务启动正常]]></content>
      <categories>
        <category>@web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[window7 修改docker安装的machine 位置]]></title>
    <url>%2F2017%2F05%2F26%2F2017-2017-05-26-docker-for-win-alter-vdi-path%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 win7下安装Docker ，默认的machine location 是在C:\users\xx.docker\machine\machines 下面，为了不占用系统盘，想修改盘符位置 google了一下，发现只需要设置MACHINE_STORAGE_PATH环境变量就可以，变量值为你想要设置的路径保存，重新运行docker quickstart 流程如下 设置MACHINE_STORAGE_PATH环境变量 运行Docker Quickstart Termina 如果想转移现有的可以试试下面的方法 关闭停止Docker的虚拟机。 打开VirtualBox，选择“管理”菜单下的“虚拟介质管理”， 选中docker创建的“disk”，然后点击菜单中的“复制”命令，根据向导，把当前的disk复制到另一个盘上面去。 回到VirtualBox主界面，右键“default”这个虚拟机，选择“设置”命令，在弹出的窗口中选择“存储”选项。 把disk从“控制器SATA”中删除，然后重新添加我们刚才复制到另外一个磁盘上的那个文件。 引用http://blog.csdn.net/u011248395/article/details/70994088]]></content>
      <categories>
        <category>@linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[swoole 做 httpserver 整合phalcon]]></title>
    <url>%2F2017%2F03%2F22%2F2017-2017-03-22-swoole-httpserver-attention%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 在整合的时候遇到的一些问题，先列出来，害怕忘了mysql连接断开问题，可能redis等也存在 原因找到了 mysql 客户端运行时，如果长时间没有操作会自动断开 swoole 开启的服务程序长时间运行，常驻内存 phalcon 里的model 的 find findFirst 方法里面，不能选择di，而只能使用默认 di 以下是model的一段源代码 ...... public static function findFirst(var parameters = null) -&gt; &lt;Model&gt; { var params, builder, query, bindParams, bindTypes, cache, dependencyInjector, manager; let dependencyInjector = Di::getDefault(); let manager = &lt;ManagerInterface&gt; dependencyInjector-&gt;getShared(&quot;modelsManager&quot;); if typeof parameters != &quot;array&quot; { let params = []; if parameters !== null { let params[] = parameters; } } else { let params = parameters; } ...... 毋庸置疑，Di::getDefault() 中的 default 肯定是一个静态属性 以下是 di 的一段源代码 ...... /** * Latest DI build */ protected static _default; ...... /** * Return the latest DI created */ public static function getDefault() -&gt; &lt;DiInterface&gt; { return self::_default; } ...... 也就是说在cli中（也就是server端）调用后，_default 这个属性就会一直在内存中，mysql的客户端（比如pdo） 由于注入到di中（di-&gt;set(‘db’,{PdoAdapter})），并且phalcon在取db时，用的 是di-&gt;getShared(‘db’,{db})，以下是 phalcn/model/manager 中的一段代码 ...... /** * Returns the connection to read or write data related to a model depending on the connection services. */ protected function _getConnection(&lt;ModelInterface&gt; model, connectionServices) -&gt; &lt;AdapterInterface&gt; { var dependencyInjector, service, connection; let service = this-&gt;_getConnectionService(model, connectionServices); let dependencyInjector = &lt;DiInterface&gt; this-&gt;_dependencyInjector; if typeof dependencyInjector != &quot;object&quot; { throw new Exception(&quot;A dependency injector container is required to obtain the services related to the ORM&quot;); } /** * Request the connection service from the DI */ let connection = &lt;AdapterInterface&gt; dependencyInjector-&gt;getShared(service); if typeof connection != &quot;object&quot; { throw new Exception(&quot;Invalid injected connection service&quot;); } return connection; } ...... 综上所述，如果app长时间没有对数据库的操作，他们之间的连接就会断开，并且不会自动重连，还有一种情况，就是如果mysql服务重启了，连接也不会重连而常规的apache/nginx方式就不会出现这个问题，毕竟每次请求都会新建一个客户端 现在问题找到了，该说解决方法了，方法很多，只是难易问题 在每次与mysql 交互时用，如果返回失败，检查错误代码，如果为 2006 / 2013，表示连接失败，再执行一次连接操作。 这种方法的思路就是很简单，就是没连上就重连 这明显不可能在业务层实现，但phalcon的源码不是php的，所以dao层也不太方便修改 不用findFirst 这类静态方法，而用builder 来操作数据。 这样虽能解决问题，但原本一句话能解决的问题需要写多句才能实现。我目前临时用的这种 方式，在model 中封装了两个方法来暂代。 其实和2差不多，只是在 modelManager 和 di 上做文章 也就是说，操作数据库时，不用默认的di（即常驻内存的di），而选用每次 请求生成的di public function findOne($parameters = null) { /** @var DiInterface $di */ $di = $this-&gt;_dependencyInjector; if(!$di || !($di instanceof DiInterface)){ throw new Model\Exception(&apos;di must be set in model&apos;); } /** @var Model\Manager $manager */ $manager = $di-&gt;getShared(&quot;modelsManager&quot;); if(!is_array($parameters)){ $params = []; if ($parameters !== null) { $params[] = $parameters; } }else{ $params = $parameters; } /** * Builds a query with the passed parameters */ $builder = $manager-&gt;createBuilder($params); $builder-&gt;from(get_called_class()); /** * We only want the first record */ $builder-&gt;limit(1); /** @var Model\Query $query */ $query = $builder-&gt;getQuery(); /** * Check for bind parameters */ $bindParams = isset($bindParams[&apos;bind&apos;]) ? $bindParams[&apos;bind&apos;] : null; if($bindParams){ if (is_array($bindParams)) { $query-&gt;setBindParams($bindParams, true); } if(isset($params[&quot;bindTypes&quot;]) ){ if(is_array($params[&quot;bindTypes&quot;])){ $query-&gt;setBindTypes($params[&quot;bindTypes&quot;], true); } } } /** * Pass the cache options to the query */ if(isset($params[&apos;cache&apos;])){ $query-&gt;cache($params[&apos;cache&apos;]); } /** * Return only the first row */ $query-&gt;setUniqueRow(true); /** * Execute the query passing the bind-params and casting-types */ return $query-&gt;execute(); } public function findAll($parameters = null) { /** @var DiInterface $di */ $di = $this-&gt;_dependencyInjector; if(!$di || !($di instanceof DiInterface)){ throw new Model\Exception(&apos;di must be set in model&apos;); } /** @var Model\Manager $manager */ $manager = $di-&gt;getShared(&quot;modelsManager&quot;); if (!is_array($parameters)) { $params = []; if ($parameters !== null) { $params[] = $parameters; } }else{ $params = $parameters; } /** * Builds a query with the passed parameters */ $builder = $manager-&gt;createBuilder($params); $builder-&gt;from(get_called_class()); /** @var Model\Query $query */ $query = $builder-&gt;getQuery(); /** * Check for bind parameters */ if (isset($params[&apos;bind&apos;])) { if (is_array($params[&apos;bind&apos;])) { $query-&gt;setBindParams($params[&apos;bind&apos;], true); } if (isset($params[&apos;bindTypes&apos;])) { if (is_array($params[&apos;bindTypes&apos;])) { $query-&gt;setBindTypes($params[&apos;bindTypes&apos;],true); } } } /** * Pass the cache options to the query */ if (isset($params[&apos;cache&apos;])) { $query-&gt;cache($params[&apos;cache&apos;]); } /** * Execute the query passing the bind-params and casting-types */ /** @var Model\ResultsetInterface|Model\Resultset\Complex $resultSet */ $resultSet = $query-&gt;execute(); /** * Define an hydration mode */ if (is_object($resultSet)) { if (isset($params[&apos;hydration&apos;])) { $resultSet-&gt;setHydrateMode($params[&apos;hydration&apos;]); } } return $resultSet; } 这样做后代码的前后对比，以findFirst为例 # 没改之前 $row = Model::findFirst([...]); # 改了之后 $row = (new Model(null,$di))-&gt;findOne([...]); # 或者用 modelManager 来生成 $row = $this-&gt;modelManager-&gt;load(Model::class)-&gt;findOne([...]); # 使用这种方式的前提是在注入modelManager服务时，就应该把di注入到modelManager中 # 1. 注入 modelManager $di-&gt;setShared(&apos;modelManager&apos;,function() use($di){ $manager = new Phalcon\Mvc\Model\Manager(); $manager-&gt;setDi($di); return $manager; }); # 2. findOne $row = $this-&gt;modelManager-&gt;load(Model::class)-&gt;findOne([...]); 如果要实例化一个模型，做 dml 操作，如save # load的参数2，如果为false，表示不新实例化一个模型，而沿用一个曾经实例化过的模型， # 目前没有没有测试为false 的情况来做dml操作，但为了不必要的麻烦，暂时不用false的情况 $row = $this-&gt;modelManager-&gt;load(Model::class，true); $row-&gt;name = &apos;jim green&apos;; $row-&gt;age = &apos;13&apos;; $row-&gt;save(); # 或者 $row = new Model([&apos;name&apos;=&gt;&apos;tom&apos;,&apos;age&apos;=&gt;&apos;13&apos;],$di); $row-&gt;save(); 4. 还在思考其它方法 目前想的是，既然要把swoole 和phalcon 合起来，就避免不了两个或多个di。 所以，我想把model这部分重写了，去掉取默认di的做法。而多个应用之各自分别 设置不同di，只不过，可能脑壳容易混乱。 get post cookie header 的 get/set 问题session 的 get/set 问题解决方法有空再写出来]]></content>
      <categories>
        <category>@web</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>phalcon</tag>
        <tag>swoole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debian 的 iptables 的常用配置]]></title>
    <url>%2F2017%2F03%2F22%2F2017-2017-03-22-debian-iptables-configure%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 常用配置（转自 http://www.cnblogs.com/kgdxpr/p/4061646.html）第一次配置#这个一定要先做，不然清空后可能会悲剧 iptables -P INPUT ACCEPT #清空默认所有规则 iptables -F #清空自定义的所有规则 iptables -X #计数器置0 iptables -Z 配置规则#如果没有此规则，你将不能通过127.0.0.1访问本地服务，例如ping 127.0.0.1 iptables -A INPUT -i lo -j ACCEPT #开启ssh端口22 iptables -A INPUT -p tcp --dport 22 -j ACCEPT #开启FTP端口21 iptables -A INPUT -p tcp --dport 21 -j ACCEPT #允许特定ip连接25端口： iptables -I FORWARD -s 127.0.0.1 -p tcp --dport 25 -j ACCEPT #开启web服务端口80 iptables -A INPUT -p tcp --dport 80 -j ACCEPT #tomcat iptables -A INPUT -p tcp --dport 8080 -j ACCEPT #mysql iptables -A INPUT -p tcp --dport xxxx -j ACCEPT #允许icmp包通过,也就是允许ping iptables -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT #允许所有对外请求的返回包 #本机对外请求相当于OUTPUT,对于返回数据包必须接收啊，这相当于INPUT了 iptables -A INPUT -m state --state ESTABLISHED -j ACCEPT #如果要添加内网ip信任（接受其所有TCP请求） iptables -A INPUT -p tcp -s 45.96.174.68 -j ACCEPT #每秒中最多允许5个新连接 iptables -A FORWARD -p tcp --syn -m limit --limit 1/s --limit-burst 5 -j ACCEPT #每秒中最多允许5个新连接 iptables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST RST -m limit --limit 1/s -j ACCEPT #Ping洪水攻击 iptables -A FORWARD -p icmp --icmp-type echo-request -m limit --limit 1/s -j ACCEPT #封单个IP的命令是： iptables -I INPUT -s 222.34.135.106 -j DROP #封IP段的命令是： iptables -I INPUT -s 211.1.0.0/16 -j DROP iptables -I INPUT -s 211.2.0.0/16 -j DROP iptables -I INPUT -s 211.3.0.0/16 -j DROP #封整个段的命令是： iptables -I INPUT -s 211.0.0.0/8 -j DROP #封几个段的命令是： iptables -I INPUT -s 61.37.80.0/24 -j DROP iptables -I INPUT -s 61.37.81.0/24 -j DROP #过滤所有非以上规则的请求 iptables -P INPUT DROP 保存重启#rehat service iptables save service iptables restart #debian iptables-save &gt; /path/to/rulefile 删除规则1#eg，删除之前添加的规则 (iptables -A INPUT -p tcp -m tcp --dport 8080 -j ACCEPT) iptables -D INPUT -p tcp -m tcp --dport 8080 -j ACCEPT 删除规则2#列出指定的链的规则的编号 iptables -L INPUT --line-numbers #删除第一条 iptables -D INPUT 1 debian的自动加载 (转自 http://blog.phiy.me/debian-iptables-persistent/)安装 iptables-persistentapt-get install iptables-persistent 保存至 /etc/iptables/rulesiptables-save &gt; /etc/iptables/rules http://www.cnblogs.com/kgdxpr/p/4061646.html http://blog.phiy.me/debian-iptables-persistent/]]></content>
      <categories>
        <category>@linux</category>
      </categories>
      <tags>
        <tag>config</tag>
        <tag>linux</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debian 以root权限运行图形程序]]></title>
    <url>%2F2017%2F03%2F17%2F2017-2017-03-17-debian-run-graphics-program-at-root%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 以 root 权限登录图形界面百度谷哥一大堆，就不写了，而且一般也用不着 最近遇到一个问题，运行一个图形程序，需要 root 权限。要按平常，直接 sudo 之。sudo xxx 拿 wireshark 来说，sudo wireshark 结果，报错了。。。 不同的程序报错信息不同，但大致意思都是连不上 X。wireshark 报错如下 No protocol specified ** (wireshark:20909): WARNING **: Could not open X display No protocol specified Unable to init server: 无法连接：拒绝连接 (wireshark:20909): Gtk-WARNING **: cannot open display: :0 某java 程序的报错如下 No protocol specified Exception in thread &quot;main&quot; java.awt.AWTError: Can&apos;t connect to X11 window server using &apos;:0&apos; as the value of the DISPLAY variable. at sun.awt.X11GraphicsEnvironment.initDisplay(Native Method) at sun.awt.X11GraphicsEnvironment.access$200(X11GraphicsEnvironment.java:65) at sun.awt.X11GraphicsEnvironment$1.run(X11GraphicsEnvironment.java:115) at java.security.AccessController.doPrivileged(Native Method) at sun.awt.X11GraphicsEnvironment.&lt;clinit&gt;(X11GraphicsEnvironment.java:74) at java.lang.Class.forName0(Native Method) at java.lang.Class.forName(Class.java:264) at java.awt.GraphicsEnvironment.createGE(GraphicsEnvironment.java:103) at java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment(GraphicsEnvironment.java:82) at java.awt.Window.initGC(Window.java:475) at java.awt.Window.init(Window.java:495) at java.awt.Window.&lt;init&gt;(Window.java:537) at java.awt.Frame.&lt;init&gt;(Frame.java:420) at java.awt.Frame.&lt;init&gt;(Frame.java:385) at javax.swing.JFrame.&lt;init&gt;(JFrame.java:189) at net.fs.client.ClientUI.&lt;init&gt;(ClientUI.java:167) at net.fs.client.FSClient.main(FSClient.java:26) 查了一下，图形界面有自己的 sudo#kde kdesudo COMMAND #gnome gksu COMMAND #COMMAND 里有参数时记得加上引号，将命令和参数包起来，如 kdesudo &apos;godie -a --bcd=efg&apos; 目前我是kde环境，试了一下，果然能用kdesudo wireshark ok 收工]]></content>
      <categories>
        <category>@linux</category>
      </categories>
      <tags>
        <tag>debian</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rsa的js加密和php解密]]></title>
    <url>%2F2017%2F03%2F02%2F2017-2017-03-02-js-php-rsa%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 零、 后面一个实例，点击跳过前面的废话一、 javascript 加密 引入相关的js库 jsbn.js , prng4.js , rng4.js , rsa.js , base64.js 他们的远程目录为： http://www-cs-students.stanford.edu/~tjw/jsbn/ &lt;script src=&quot;http://www-cs-students.stanford.edu/~tjw/jsbn/jsbn.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://www-cs-students.stanford.edu/~tjw/jsbn/prng4.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://www-cs-students.stanford.edu/~tjw/jsbn/rng.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://www-cs-students.stanford.edu/~tjw/jsbn/rsa.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://www-cs-students.stanford.edu/~tjw/jsbn/base64.js&quot;&gt;&lt;/script&gt; 本 blog 也拷贝了这几个库，网址的目录为： http://blog.lopy.win/assets/rsa/，将几个文件名加在后面就可以了。 github地址：https://github.com/uljjmhn520/uljjmhn520.github.com/tree/master/assets/rsa //jquery 方便dom操作 &lt;script src=&quot;//cdn.bootcss.com/jquery/2.1.3/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://blog.lopy.win/assets/rsa/jsbn.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://blog.lopy.win/assets/rsa/prng4.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://blog.lopy.win/assets/rsa/rng.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://blog.lopy.win/assets/rsa/rsa.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://blog.lopy.win/assets/rsa/base64.js&quot;&gt;&lt;/script&gt; js 代码，第一部分 //创建一个rsa类，只有一个加密方法，构造函数为公钥中的 n 和 e 也就是模和指数。 var MyRsa = function(module,eVal){ module = module || &apos;&apos;; eVal = eVal || &apos;010001&apos;; var rsaObj = new RSAKey(); //构造函数 var init = function(module,eVal){ if(module){ rsaObj.setPublic(module,eVal); } }; init(key,eVal); //加密 this.encrypt = function(str){ var strEncoded = rsaObj.encrypt(str); if(!strEncoded){ alert(&apos;hello what\&apos;s your name&apos;); return false; } return hex2b64(strEncoded); } } js代码，第二部分 //n和e为rsa的模和指数，他们的值是从密钥对中获得的，后文会给出php 中获取的方法 var n =&quot;E0F1E67A3E1E54B1820A481F1DFC98545542B85EAEC149627591593C19A25B3B6CDAAA9346D83EF695193FA268E3ED27C9B57DCFB5B6FB873D646FA3947105E4ACF07EDF623D321881D8930E0CFD391191F2EB3B3EB3DF2409F25B96B2BD4C5D2EAF42B43059D2FDDBAF5BE51E7F66E69B617FE319DFC2AD2567A841D765EB0DF5BAB631146EB6FD5688028658A0AEAF1CBD470BF437BCFA6641159E8C2F857B0C7D806326C6D3037DEAD1EC463673E0CA30D51EAF7F70EB7AFD46A765FB5FB4C89791A4CF4C4072E4D29D5DEDE90D75DC2D9669AEB888133F349179264EFF2DF0BCEFDA11FDAC32B57F75E2D2072ADC117DDAC3BEA8F431253228594BF0419B&quot;; var e = &apos;010001&apos;; var myRsa = new MyRsa(n,e); var encoded = myRsa.encrypt(&apos;hello world&apos;); console.log(encoded); // result，以下为结果之一，每次加密的结果都可能不一样 // XJJeZhc4tYp50OXDAyBS6aK0lWOPNR6IVOM4auccxb+uk0+d5GewFq9ffAWhlBpAiRTuo1IbKm8e23UdU3kbIFs9nNAMCSdj/2FL3C9NrXlW67Jfs6azAMHMHKW3f3rXPCRMTvFGq09KdobwLiy71GidRZtbQYQEaZ8QhHpZC/QYem9EAdu4ULdBX5e1uigIPm3ukzK6RUKRbBYM44ApoL6kNUdbELvC2J6psqs1YxprwAw9D5C8N41tWFRwx7MIPx83TG8aGYDCU/q1E5Xd7fDpXlm4gZxPPXMHwIT4WJBvzDZoCCpxJSEYEzHzfF6HTTWcWo8BBbUeC8qssCHiyA== 二、php 解密 解密用的私钥，与加密用的公钥为一对，公钥可以用私钥生成，后文中会介绍 -----BEGIN PRIVATE KEY----- MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDg8eZ6Ph5UsYIK SB8d/JhUVUK4Xq7BSWJ1kVk8GaJbO2zaqpNG2D72lRk/omjj7SfJtX3Ptbb7hz1k b6OUcQXkrPB+32I9MhiB2JMODP05EZHy6zs+s98kCfJblrK9TF0ur0K0MFnS/duv W+Uef2bmm2F/4xnfwq0lZ6hB12XrDfW6tjEUbrb9VogChligrq8cvUcL9De8+mZB FZ6ML4V7DH2AYybG0wN96tHsRjZz4Mow1R6vf3Drev1Gp2X7X7TIl5Gkz0xAcuTS nV3t6Q113C2Waa64iBM/NJF5Jk7/LfC879oR/awytX914tIHKtwRfdrDvqj0MSUy KFlL8EGbAgMBAAECggEBAIWKtpRd6m3HT/dAp9CKk/iFAW4pL8AqC9zWJE7MvRlC ZzZNy89kM8T58RpZFcIymctjBsTYEUC0IhtNN6S5kJEYplH71fuUkP4NEAhoZ7CI oMfBJNPtvwxLJ2l+RrCg9DTx8Ty986WR9ejeOmBnrDQ9jJ16unKfxWEOb9JeyO/I pcuNi1+FKjCJDExNrEbPsiVdHK3tWI7a3lKVA6pTVSypjp3gLlbxwHpgVaEm+dak RFiPoyCoxYigQhsmnKp0ou+2qrJIl7b6NM+mfWD/o21zhAD3q/2vDfc5M661Uhlj Q/CvinB6P39Zs4gIhZa17AeZOXEgekcx/I068vLRKLkCgYEA9xaztzsvJTOQOjYX ZAaTssVO1VpDp9YbaXzLhrmc9HZVTgIiuDumKHrZ98r0yxQ21CszyJUEVbDSmVze hYnkMpC6lV03H8KuODNtjbeUkEw87g3+wiEuDAPUPHpVo/Afzxnd3kvH0dOKkMkY H09tuBbI7JXEbeJtxOuCxc7QCT0CgYEA6Q7AXNnerxcIcfBmFQR2HArmcIQcfmyx 1D7USxwbub2kdSTd1Qr3pFbyPiqGmO2YjrvJCnXPH1ofq6gWWTH46Q0uxrNjp2Xn ZAPG03I+2gyGzs4ASSdFbDJwmQ6t0Pk253qArlzlcQgrGqtRS/4SzfivYiO6B27u aon8174Us7cCgYAYDsjOxV9wwtV/JXcfkRheZqGnWlOOCuW+Xp0+b+IdV0w0/TY+ M+iYtmV0n/k3sK8p907ib8ftQ/stXYJ5BBUI61iPZHUSjZUC+dbn3oEDj7i7APfW FP7zwoeun8ao4J9oPb+BfmVlQ7CRKlND8Srgqq9Dgc2PWWWQr9GayuksjQKBgQCM Vr2vK+LUPGJxefl+nnkg2c954ZPm7T0IOe1MbVikuHXXtKOALmKBK3ojxSfX3vsG uD2PdvGKR5LaoxUSEO16KN4J+OwBWXPE3iFUIm+GjhR/Y7z4UBWV2anEAPrZ47gU G8hxNq9TKUALhy4lPJHGRgIWbr0OzNX0gbMnluaQcQKBgDyQeTvFpPuziNltPVm0 BEbD6mSgHTky1i5w/k2UiR72tUHb3ekx98fPc0YHqczYbc7l8vP7mDO0+ZmtdFmq JjcixY3ZlvWeVjZ/QlI7wpgCy5hsgSRnxdy94IrLhrA5zlL0dDC0mAVzTPzJltIX QrbpjdKjcOCrdDny0WUw+OX4 -----END PRIVATE KEY----- php 代码部分 $privateStr = &apos;上文中的私钥&apos;; $pKey = openssl_pkey_get_private($privateStr); //encoded 为 上文js加密后的密文 $encoded = base64_decode($encoded); openssl_private_decrypt($encoded,$decrypted,$pKey,OPENSSL_PKCS1_PADDING); echo $decrypted; //如果一切正常的话，就能解密出结果 hello world 三、一些说明 php 的openssl 扩展官网 http://php.net/manual/en/ref.openssl.php 创建密钥对 $ssl = openssl_pkey_new([]); 提取私钥 openssl_pkey_export($res, $privKey); //privKey 就为私钥 格式为 -----BEGIN PRIVATE KEY----- ...... -----END PRIVATE KEY----- 获取detail，包括公钥、模、指数等信息 方式一，从密钥对里面提取 $detail = openssl_pkey_get_details($ssl); //公钥 $publicKey = $detail[&apos;key&apos;]; //模，值为二进制乱码，转为16进制 $module = $detail[&apos;rsa&apos;][&apos;n&apos;]; $module = bin2hex($module); //指数，值为二进制乱码，转为16进制 $exponent = $detail[&apos;rsa&apos;][&apos;e&apos;]; $exponent = bin2hex($exponent); //一般结果为 010001 （65537） 方式二，从私钥里提取 $privateKeySource = openssl_get_privatekey($privKey); $detail = openssl_pkey_get_details($privateKeySource); //后面取模、指数等信息同方式一 方式三，从公钥里提取 //$publicKey 为方式一中提取的 publicKey $publicKeySource = openssl_get_publickey($publicKey); $publicKeyDetail = openssl_pkey_get_details($publicKeySource); //后面取模、指数等信息同方式一 //从公钥里面提取的 detail 的内容较少 解密 // $encoded 为已被加密的密文 $encoded = base64_decode($encoded); //私钥 , $pKey = openssl_pkey_get_private($privKey); //私钥解密 openssl_private_decrypt($encoded,$decoded,$pKey,OPENSSL_PKCS1_PADDING); echo $decoded; 四、完整的实例 以下内容基于 phalcon 的 controller ，如果你没有使用phalcon，可能会修改一部分代码 里面有三个action index：html 页面，包括js加密部分 decode：php 解密部分，接收post数据，与页面index 的ajax交互 create：rsa 要用到的一些基本函数，没多大用，就一些注释 &lt;?php /** * @brief * Created by PhpStorm. * User: zy&amp;cs * Date: 17-3-2 * Time: 上午11:47 */ namespace App\Modules\Tester\Controllers; class RsaController extends ControllerBase { /** * 内置了几个私钥，用该方法获取一个， * * 可以自己用 createAction 自己往后面加，实际操作中用缓存或数据库就能解决了 * * * @param bool|int $key 默认取第一个，$key === false 时，取所有 * @return array */ private function rsaPrivateKey($key=false) { $rsaKeys = []; $rsaKeys[0] = &lt;&lt;&lt;rsakey -----BEGIN PRIVATE KEY----- MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDMYA9a+x7XxFh8 Ihk9EK+6N0xZNq8qhBH5jypFO7zVvOHYPDjr1OAoKXYESDF5Yk+bbivXRY3Ptjbb QF2f0kNTkGBO0bwUmmDJ8RWs14uA+OyPmByHpBxRDLvddNNe3sj0GWbOKMXhSNQD zdu+U7vCtpjrHfKcoa8X5VjVln/A/gmQ4sCl3eQgeWcBciMV1AMY3b5Ez3ZuVM2C HNQl4dyGzMtEmSxOTT9oFFlDI64q+6QjlDOeo0cOD3lZDuR7x1knXWtLJtQ4v2Al 8Ovoci6b33DApSRJJCFMclIhakIRHfmQxSANxu7L25OslJ0UhbOZEVoWm5hkkjrC h3opznJjAgMBAAECggEBAIFHgm8ayrfSC+b56t0l4QL6V+FXJhbO1E/4r9R7pUfO 403VSmxjjCfbkjvDLwiJl7HKTxEtfjcWHD00ygR/DPefLEyvfznJLdCQIBXlguli jMGIhwOGXCMo2u2LKOmqI5PFPbLLN+D6IKMHZSlP7kWNG84ec4mA/TEwcrEpMkbx SaK7J5psPJ14OwRyj3Ok/Q7cF6jfqWmBKDVErHlsQHrqVVuq3Ik67u9E4bQvdgRC A+1z61ruu9pmyNhGBj0KsQCBU/e+4X1TpKVPgnBS/q2qLGT5JwL556Fax5xiT4Pj uFI607WXdjsl5Zi1pYbxTJBgJhfeUs64pRkwHzMp/4ECgYEA7b5PwkozKiYWFBzq JhutrykTTAZj+L4WomV3fwWNYJLboBX4fq7w4/rOP1xQtbtlSVeQxRV6+uka8QU5 f+f+cH+/h2d/G0/ppwOPuavkW4pXhYNFlrJ6l9/KMG9Niw+R4Jrf09h47QgEXfjm uJfBlTnLb5FyvZ0miAcuabuhoh8CgYEA3BHHZPsDaJpSLaoN8RUYfbTyOU1kj4Pp 4N7psZ5AKxZblBMPYubZMcR+accZ2TDlch4rZJBOyfay6Cw4ZzneKeUO5NI/hr2g Qh6Zd2ZpxHEE8SxYRDOOf3l8gP83aspLzL8KT/XNySJraRacaknXETiP+pNcKqFo zy0J3ujVDz0CgYBKnsM1/kgU4KNpaLHtiB55rfDKme7i8fb0vdhF3B5Fw5J/qqW2 TX56cAwwQu9qOwlNfdiIo3dYLbYxFCy6Ar0P3mjlPQzeK7TwoOOJqXQhb0iNNWiw JhDofmtdzHGQRjDJSJMcUQOTkkKcpDT2l1tBVUSPHh3feeXQKEDfGu9ejQKBgQCR XYUSZORZgiZqV3wiFUc6Mf4Wb9LPIdmpWlWPp/LHA1u2sehl8grh3uOJx6SBXNUS zm7nXJNOwRBoYF1ZglYH4nA2IdMok7V6N3Az+IhA5E7ZZ+teEZg9B+h/5RWcCsiL FF4hd0JZa8z7e54Sb3gKvgwM/q3Q0xHCWAO/JJkoGQKBgQCXP+SGszS+YExHp+zO Bv1KRtv98YO9hZq9c+eXbVVbqEOo2/QM3G6joSdla7fD4SuEHA0MoEalgPkZ2teV +Wsq/CbbrlZTTbdjMXuJu6VY7aKXG4nq3ZaU1cjxKSovP5S4NNueCNvUYWXp218E S19cTtlOxaiqzUFB6csgohAxwQ== -----END PRIVATE KEY----- rsakey; $rsaKeys[1] = &lt;&lt;&lt;rsakey -----BEGIN PRIVATE KEY----- MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDETB/jy7cTG9SN EAgqh+wgIn7BCjBUGYP5po5oAYSsksQeMzBow2upsAw1JTizUwPyRhiuA7+WCUNg W65zh4Lj/gnjRa2SQWAx1PgUh5xhKJBKU84UPrPRt6CRL5HRdqL6vi0YU26lpewS HPC2TWVuXyQrKGPLCkcRG0gnWEyCN53Ua/zpYYas3gNr3Qs64ZT60VIGXdXktpbS ozdofOmI8rXUzzVJbj5ahlnGzTtM+XBtlDvY2Sb2sB3FjH6jXLyTdr26AcpuSRJQ ZAJffHBm1bZwWJszpVKYNP7bYpt/Ey5uCuJUNq/XlNlmKKN5H9mzG2UITirduxRv vfV+QzVDAgMBAAECggEAdKO/Nz5vVF1vGTrzf0Iw3o9gvhfty6s1rnx3lfmA+oJj IobMNxQXv0aqmlG5tWSYrbdVJuF3UBHFBVa0/FUDQ7JJ8dAPaR6LqFCh8KD8HQdb Za8SfxkbBHyWXm7juJFEGrYyWYgJ8Uf8VG754Xlv0fuapEJludorjFCnuSlQnPag tw6t3tcj/BzbXTrrGi6V36vm9lkg4qrdozJcYl9cIXs/SAdWUX5jIkCAHVSrNoKA LSwylPeNMSVzJu3o6ivj4OPfn6/HuNZZ3Z18O/veNB13B4xb4M9f7RduQQFNC9Bq qH8nyfRiYtFFFj3SRfmF74GJCYe3xP4MDB3PV5DpUQKBgQDnpt1qqPiVbuaL4Kro a3b62u66RZnZxGCvvpaBeP7+cx69RGwcXxfYRNVSQ3VRbChuhsbw9UWrFY+akOT7 5QLCorxpyaSiYkv0aHpFqjWX9IaKY3PJN7hq7VICHTRehdpiNpp1Y092HWz6+qxn 4h8D4+bTmyQmU7S5gvfc5H00xwKBgQDY7fcXAfbuxnKw8j8BZQAhkjF2RvN0DGD/ Uocee06LKrXzGWwP0ydCismxL50DvsddmJ92CEHqBtf8zoq32MlMTlCyBvSmFx/Z PEKalHxNlHuDDjnMSI4yYhd9losFhagXI767Uhce28AiNoHKd8dXM+8NY77QxZJ9 g/yzyatHpQKBgA1vbx4ViL1Z/kMUl7T9LpxkAD6LdN3dduIagq4lr1xgnuLJSh/n IAHqFBk+UlqTlFC8vmMRRqYijP6g8rbtVFiniZf1GvhUDSWyvYy2z37trrPuCrQb 6DVDaGM5AGWPC9hwZEr0pJIsKLrxuPgZdEUMfcG+GL2kUzIDN473LY/XAoGANcji f5DcIZ2QaDDX0EezfZ9apiG3UOmUzxkuKS+XbMfdLvX5pf7LeCMjGMxeWMRfd+RU fRZVCWpC+QpYuHaGimXMeidhVyDao6jeNqdkHnQXH4pSaEUBBJrvihLeSzM1Vu9k 5drXoq4HeDQdgA6snQFiXuaBNBAYXwhvikAROIUCgYEA3SkKhaZVXgsfIQpKwR1F WrTgh1976+40ZY8a1Ktg9W7HJm8FmyEcsgnZxVM0IMVZ4W6LS1HboNL3XR0C7UtC Ga/EXZWqau7eMuob1lz9MyxQMYtiNKRBpGrJyo9HoFjS1M4xVGyVq0C6V3SplMB4 vjjY7Snq6YKVk8Rw770Tnus= -----END PRIVATE KEY----- rsakey; $rsaKeys[2] = &lt;&lt;&lt;rsakey -----BEGIN PRIVATE KEY----- MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDg8eZ6Ph5UsYIK SB8d/JhUVUK4Xq7BSWJ1kVk8GaJbO2zaqpNG2D72lRk/omjj7SfJtX3Ptbb7hz1k b6OUcQXkrPB+32I9MhiB2JMODP05EZHy6zs+s98kCfJblrK9TF0ur0K0MFnS/duv W+Uef2bmm2F/4xnfwq0lZ6hB12XrDfW6tjEUbrb9VogChligrq8cvUcL9De8+mZB FZ6ML4V7DH2AYybG0wN96tHsRjZz4Mow1R6vf3Drev1Gp2X7X7TIl5Gkz0xAcuTS nV3t6Q113C2Waa64iBM/NJF5Jk7/LfC879oR/awytX914tIHKtwRfdrDvqj0MSUy KFlL8EGbAgMBAAECggEBAIWKtpRd6m3HT/dAp9CKk/iFAW4pL8AqC9zWJE7MvRlC ZzZNy89kM8T58RpZFcIymctjBsTYEUC0IhtNN6S5kJEYplH71fuUkP4NEAhoZ7CI oMfBJNPtvwxLJ2l+RrCg9DTx8Ty986WR9ejeOmBnrDQ9jJ16unKfxWEOb9JeyO/I pcuNi1+FKjCJDExNrEbPsiVdHK3tWI7a3lKVA6pTVSypjp3gLlbxwHpgVaEm+dak RFiPoyCoxYigQhsmnKp0ou+2qrJIl7b6NM+mfWD/o21zhAD3q/2vDfc5M661Uhlj Q/CvinB6P39Zs4gIhZa17AeZOXEgekcx/I068vLRKLkCgYEA9xaztzsvJTOQOjYX ZAaTssVO1VpDp9YbaXzLhrmc9HZVTgIiuDumKHrZ98r0yxQ21CszyJUEVbDSmVze hYnkMpC6lV03H8KuODNtjbeUkEw87g3+wiEuDAPUPHpVo/Afzxnd3kvH0dOKkMkY H09tuBbI7JXEbeJtxOuCxc7QCT0CgYEA6Q7AXNnerxcIcfBmFQR2HArmcIQcfmyx 1D7USxwbub2kdSTd1Qr3pFbyPiqGmO2YjrvJCnXPH1ofq6gWWTH46Q0uxrNjp2Xn ZAPG03I+2gyGzs4ASSdFbDJwmQ6t0Pk253qArlzlcQgrGqtRS/4SzfivYiO6B27u aon8174Us7cCgYAYDsjOxV9wwtV/JXcfkRheZqGnWlOOCuW+Xp0+b+IdV0w0/TY+ M+iYtmV0n/k3sK8p907ib8ftQ/stXYJ5BBUI61iPZHUSjZUC+dbn3oEDj7i7APfW FP7zwoeun8ao4J9oPb+BfmVlQ7CRKlND8Srgqq9Dgc2PWWWQr9GayuksjQKBgQCM Vr2vK+LUPGJxefl+nnkg2c954ZPm7T0IOe1MbVikuHXXtKOALmKBK3ojxSfX3vsG uD2PdvGKR5LaoxUSEO16KN4J+OwBWXPE3iFUIm+GjhR/Y7z4UBWV2anEAPrZ47gU G8hxNq9TKUALhy4lPJHGRgIWbr0OzNX0gbMnluaQcQKBgDyQeTvFpPuziNltPVm0 BEbD6mSgHTky1i5w/k2UiR72tUHb3ekx98fPc0YHqczYbc7l8vP7mDO0+ZmtdFmq JjcixY3ZlvWeVjZ/QlI7wpgCy5hsgSRnxdy94IrLhrA5zlL0dDC0mAVzTPzJltIX QrbpjdKjcOCrdDny0WUw+OX4 -----END PRIVATE KEY----- rsakey; $rsaKeys[3] = &lt;&lt;&lt;rsakey -----BEGIN PRIVATE KEY----- MIIBUwIBADANBgkqhkiG9w0BAQEFAASCAT0wggE5AgEAAkEA0ZJCQOOdXAGtSN1W MBNQp27kzLC7qE275nNgJsxk7VN2okNDPoTyn2jKO66VSy6j2Jgnsa2Ivd8w0kZQ s96viwIDAQABAkANFdDFNHES2Zf0QL2s6sfSbH4kubQ94fyleva59XEn0D1RtQou ELkG8ziIYbqucTMJm5IkyR7wFYDCDuGgDU6BAiEA9hRhdeQfdwLzNUQfrReNEScL LhDMGbDqVsEvu8ik8zsCIQDaBRndLKubqbTtE/HP6tFG8bNHLpCfRbv+YTBgbyvP 8QIgfdbKSClSVd/yU2j08eU7RGw88V+xn+myzI6aRGNExwUCIHBIIEHgN6E7jYpr syW5cX5wDDykpqbgaylfNGL13kKBAiAZwTtHJmMuApSOrdesqoeNMOqKhoDgyNZy GbnWQa+Dxg== -----END PRIVATE KEY----- rsakey; $rsaKeys[4] = &lt;&lt;&lt;rsakey -----BEGIN PRIVATE KEY----- MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAMpVIE75OR2lftwn U2WXszG5YPCxZno7Q2cdfpXQ2aW69hcdjiQDgBeVfSngRtrK2lXlkiBw5wIuK9MI e0jL1tatPRJ+/kHSnQadh01NpHsz/FiMQsJ8jOdfP2zhCO6F6p6cgTH7ccSp3AHq XvmGIPZByba5N3KVgqSayux4cDQhAgMBAAECgYArPA1vUqn1v8tf17dmWggcc/RW +lFfhRJeElteQAaB93VmcxZQc78HSxY3wIjjb70/5ZJYBEgYmy0aJxHQ+F2rmE7J viFtDUNp3wC64juvntuSoEOBjmjYVYhfNHOvoVrh/Lh8/8cj5bba2D2/G0h+DAhC NuHDA2yesAmUm3icEQJBAPROBPTAHSdAh46osdpnjFp1skrsK5ZAzvLzvNGA9WtO 581u7cbKdmfKZOa/0G3grOtC9reRovNxHzyLqhcD9HMCQQDUBLuNsdZOfOe5fRnl oH3Bs/U63VHpGuhD619kX3ZFC9J0yykSk37eWm6+lXJ9iEmMOpbIByzEzt5FvxCQ teQbAkBk0gXNk7L0Tfcjco7jWTRc6JGJxek++sPtE5VqyFN/03JqH0tVbJxsvOPj LmmvzrbN6Da1Dw82dAq2C9VH5kPtAkAE18rU9L/5cP72DLZ/uUfGGe87Ff0d/wBZ NNIr/8Y604dOJandg8L9H0GyVsWTun47lscE8K0EHdmT7EZbl9wLAkEA5vV71Jk8 zxGDhpDdqmviFDTMGjl2zQwIh8AW+OL+R1GAlsJlcWy0E4C6lm3xohv5vO1V9Png nWMKYJf8FW2DvA== -----END PRIVATE KEY----- rsakey; $rsaKeys[5] = &lt;&lt;&lt;rsakey -----BEGIN PRIVATE KEY----- MIIBFAIBADANBgkqhkiG9w0BAQEFAASB/zCB/AIBAAIzAVKoys24WgfliPeAh2LH vhFEQ1KmxEETTrOwjSLtYFgA6opEvcND4Hie61syD3i/g7sBAgMBAAECMwDfbilP DH+pkhCJaizoSOvnLGhWUVxNqtVSKTXJX/Nri/a5Ye3sr+ZZIaCcxZCeBOejIQIa AbPKiMN2IzV+WpDMr9zspM1Khz2Hy3y0hKUCGgDG8O8syaInZ7/qdrn2/1TIuZkO CkE4+KItAhlgyLtlBai+Kai9fegU3a2gNkwg2zbTJFhNAhkyNURnrUu7XjfVWLl+ WNpw/kZegMANPNLRAhoBgZPB6KHFUtqcodgnJvRkyt8wVlUk0Lx6Qg== -----END PRIVATE KEY----- rsakey; if($key === false){ return $rsaKeys; } if (!isset($rsaKeys[$key])) { $key=0; } return $rsaKeys[$key]; } /** * @param $id * @return array */ private function getDetailFromPKId($id) { $key = $this-&gt;rsaPrivateKey($id); $resource = openssl_get_privatekey($key); return openssl_pkey_get_details($resource);; } private function getHtml($keyId,$rsaModule,$rsaExponent) { //rsa 的那几个js $rsaAssets = [ &apos;jsbn.js&apos;, &apos;prng4.js&apos;, &apos;rng.js&apos;, &apos;rsa.js&apos;, &apos;base64.js&apos;, ]; $rsaJsPre = &apos;http://blog.lopy.win/assets/rsa/&apos;; $rsaJs = &apos;&apos;; foreach($rsaAssets as $val){ $rsaJs .= &apos;&lt;script src=&quot;&apos; . $rsaJsPre . $val . &apos;&quot;&gt;&lt;/script&gt;&apos;; } //切换 privateKey $switchStr = &apos;&apos;; foreach($this-&gt;rsaPrivateKey() as $key=&gt;$val) { $switchStr .= &apos;&lt;li&gt;&lt;a href=&quot;index?key_id=&apos; . $key . &apos;&quot;&gt;密钥 - &apos; . $key . &apos; &lt;/a&gt;&lt;/li&gt;&apos;; } //密钥长度 $moduleLength = strlen($rsaModule) * 8 / 2; //为毛要除以2 ，因为 bin2hex 后，长度为两倍 //html 代码 $html = &lt;&lt;&lt;html &lt;html&gt; &lt;head&gt; &lt;script src=&quot;//cdn.bootcss.com/jquery/2.1.3/jquery.min.js&quot;&gt;&lt;/script&gt; $rsaJs &lt;/head&gt; &lt;body&gt; &lt;script&gt; //class rsa var MyRsa = function(key,eVal){ key = key || &apos;&apos;; eVal = eVal || &apos;010001&apos;; var rsaObj = new RSAKey(); var init = function(key,eVal){ if(key){ rsaObj.setPublic(key,eVal); } }; this.encrypt = function(str){ var strEncoded = rsaObj.encrypt(str); if(!strEncoded){ alert(&apos;hello what\&apos;s your name&apos;); return false; } return hex2b64(strEncoded); } init(key,eVal); } function submitCheck(){ var rsaModule = &quot;$rsaModule&quot;; var rsaExponent = &quot;$rsaExponent&quot;; var myRsa = new MyRsa(rsaModule,rsaExponent); $(&quot;[name=input]&quot;).val(myRsa.encrypt($(&quot;#input&quot;).val())); var url = &quot;decode&quot;; var data ={ key_id:$(&quot;[name=key_id]&quot;).val(), input:$(&quot;[name=input]&quot;).val(), }; $.post(url,data,function(json){ if(json.flag ===0){ $(&apos;#decoded&apos;).val(json.decoded); }else{ alert(json.msg); } }); return false; } &lt;/script&gt; &lt;style&gt; input.full{ width: 100%; } &lt;/style&gt; &lt;ul&gt;$switchStr&lt;/ul&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;ul&gt; &lt;input type=&quot;hidden&quot; name=&quot;key_id&quot; value=&quot;$keyId&quot;&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;密钥长度&lt;/li&gt; &lt;li&gt; &lt;input type=&quot;text&quot; readonly value=&quot;$moduleLength&quot; class=&quot;full&quot;&gt; &lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;模（n）&lt;/li&gt; &lt;li&gt; &lt;input type=&quot;text&quot; readonly value=&quot;$rsaModule&quot; class=&quot;full&quot;&gt; &lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;指数（e）&lt;/li&gt; &lt;li&gt; &lt;input type=&quot;text&quot; readonly value=&quot;$rsaExponent&quot; class=&quot;full&quot;&gt; &lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;输入要加密的字符串：&lt;/li&gt; &lt;li&gt; &lt;input type=&quot;text&quot; id=&quot;input&quot; class=&quot;full&quot;&gt; &lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;js加密后&lt;/li&gt; &lt;li&gt; &lt;input type=&quot;text&quot; name=&quot;input&quot; readonly class=&quot;full&quot;&gt; &lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;php解密后&lt;/li&gt; &lt;li&gt;&lt;input type=&quot;text&quot; id=&quot;decoded&quot; readonly class=&quot;full&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt; &lt;button type=&quot;submit&quot; onclick=&quot;return submitCheck();&quot;&gt;encode &amp;&amp; decode&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; html; return $html; } /** * * @return bool */ public function indexAction() { $keyId = $this-&gt;request-&gt;get(&apos;key_id&apos;,&apos;int&apos;,0); $keyId = $keyId &lt; 0 ? 0 : $keyId; //取一个私钥 private key $detail = $this-&gt;getDetailFromPKId($keyId); //取得该密钥对的 模 和指数，也是 n 和 e $rsaModule = strtoupper(bin2hex($detail[&apos;rsa&apos;][&apos;n&apos;])); $rsaExponent = bin2hex($detail[&apos;rsa&apos;][&apos;e&apos;]); //输出html echo $this-&gt;getHtml($keyId, $rsaModule, $rsaExponent); return false; } /** * @return bool */ public function decodeAction() { //post 参数 $keyId = $this-&gt;request-&gt;getPost(&apos;key_id&apos;, &apos;int&apos;, 0); $input = $this-&gt;request-&gt;getPost(&apos;input&apos;, [&apos;string&apos;, &apos;trim&apos;], &apos;&apos;); $json = [ &apos;flag&apos; =&gt; 1, &apos;msg&apos; =&gt; &apos;&apos; ]; if($keyId &lt; 0){ $json[&apos;msg&apos;] = &apos;what\&apos;s your name?&apos;; }else if(!$input){ $json[&apos;msg&apos;] = &apos;how old are you&apos;; }else{ $str = base64_decode($input); //私钥 $pKey = openssl_pkey_get_private($this-&gt;rsaPrivateKey($keyId)); //私钥解密 openssl_private_decrypt($str,$decrypted,$pKey,OPENSSL_PKCS1_PADDING); //结果 $json[&apos;flag&apos;] = 0; $json[&apos;decoded&apos;] = $decrypted; } $this-&gt;response-&gt;setJsonContent($json); return false; } //test public function createAction() { echo &apos;&lt;pre&gt;&apos;; //创建密钥对 //$rsaPair = openssl_pkey_new([]); $rsaPair = openssl_pkey_new([ &apos;private_key_bits&apos;=&gt;401 ]); //get 私钥 openssl_pkey_export($rsaPair, $privateKey); var_dump($privateKey); // get detail of private key //array( // bits 位数 // key 公钥 // rsa =&gt; array( // n 模 // 。。。。。。 // ) // type //) $privateKeyDetail = openssl_pkey_get_details($rsaPair); /* //这样也行，两种方法 $privateKeySource = openssl_get_privatekey($privateKey); $privateKeyDetail = openssl_pkey_get_details($privateKeySource); */ //ob_clean();var_dump($privateKeyDetail);return false; //get 公钥 public key var_dump($privateKeyDetail[&apos;key&apos;]); var_dump(&apos;------------------------------------------ private key start ------------------------------------------&apos;); //模 n ，一般用hex 显示 var_dump(strtoupper(bin2hex($privateKeyDetail[&apos;rsa&apos;][&apos;n&apos;]))); //指数 e var_dump(bin2hex($privateKeyDetail[&apos;rsa&apos;][&apos;e&apos;])); var_dump(strtoupper(bin2hex($privateKeyDetail[&apos;rsa&apos;][&apos;d&apos;]))); var_dump(&apos;------ p and q ------&apos;); var_dump((bin2hex($privateKeyDetail[&apos;rsa&apos;][&apos;p&apos;]))); var_dump((bin2hex($privateKeyDetail[&apos;rsa&apos;][&apos;q&apos;]))); var_dump(&apos;------------------------------------------ private key end ------------------------------------------&apos;); var_dump(&apos;&apos;); var_dump(&apos;------------------------------------------ public key start ------------------------------------------&apos;); //也可以用public key 获取 detail //public 的 detail 里面的 rsa 的东西要少些 $publicKeySource = openssl_get_publickey($privateKeyDetail[&apos;key&apos;]); $publicKeyDetail = openssl_pkey_get_details($publicKeySource); var_dump(strtoupper(bin2hex($publicKeyDetail[&apos;rsa&apos;][&apos;n&apos;]))); var_dump(bin2hex($privateKeyDetail[&apos;rsa&apos;][&apos;e&apos;])); var_dump(&apos;------------------------------------------ public key end ------------------------------------------&apos;); var_dump($publicKeyDetail); echo &apos;&lt;/pre&gt;&apos;; return false; } } rsahttp://www-cs-students.stanford.edu/~tjw/jsbn/ demohttp://www-cs-students.stanford.edu/~tjw/jsbn/rsa.html]]></content>
      <categories>
        <category>@web</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>js</tag>
        <tag>rsa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debian realtek 无线网卡安装]]></title>
    <url>%2F2017%2F02%2F20%2F2017-2017-02-20-debian-realtek-driver%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 安装sudo apt-get install firmware-realtek 命令行设置重启sudo reboot 参考资料 https://packages.debian.org/jessie/firmware-realtek]]></content>
      <categories>
        <category>@linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP自动捕捉页面500错误示例]]></title>
    <url>%2F2016%2F08%2F19%2F2016-2016-08-19-php-error-http500%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 一、解决方法 通常程序发生致命错误的时候页面空白，想获取错误信息也不难!主要是利用两个函数： 1、error_get_last() 获取最后一次发生错误信息，结构如下： Array ( [type] =&gt; 8 [message] =&gt; Undefined variable: http://www.111cn.net [file] =&gt; C:WWWindex.php [line] =&gt; 2 ) 2、register_shutdown_function() 在脚本停止执行时注册一个回调函数 有了这两个函数就可以监控致命错误了： error_reporting(E_ALL); //E_ALL function cache_shutdown_error() { $_error = error_get_last(); if ($_error &amp;&amp; in_array($_error[&apos;type&apos;], array(1, 4, 16, 64, 256, 4096, E_ALL))) { echo &apos;&lt;font color=red&gt;你的代码出错了：&lt;/font&gt;&lt;/br&gt;&apos;; echo &apos;致命错误:&apos; . $_error[&apos;message&apos;] . &apos;&lt;/br&gt;&apos;; echo &apos;文件:&apos; . $_error[&apos;file&apos;] . &apos;&lt;/br&gt;&apos;; echo &apos;在第&apos; . $_error[&apos;line&apos;] . &apos;行&lt;/br&gt;&apos;; } } register_shutdown_function(&quot;cache_shutdown_error&quot;); 二、附上本地服务器测试方法 下面来说说显示PHP错误提示消息的三个方法。 1、php.ini配置 php.ini 配置中与此相关的有两个配置变量。下面是这两个变量及其默认值 display_errors = Off error_reporting = E_ALL &amp; ~E_NOTICE display_errors 变量的目的很明显 —— 它告诉PHP是否显示错误。默认值是 Off。现在我们的目的是显示错误提示，那么： display_errors = On E_ALL，这个设置会显示从不良编码实践到无害提示到出错的所有信息。E_ALL 对于开发过程来说有点太细，因为它连变量未初始化也显示提示，而这一点正是PHP“高级”的一个特征。幸好，error_reporting的默认值是“E_ALL &amp; ~E_NOTICE”，这样就只看到错误和不良编码了，对程序无不利的提示则不会显示。 修改php.ini后需要重新启动Apache，这样才可以在apache中生效，当然你如果只在命令行下测试程序，是不需要这一步的。 配置php程序中 &lt;?php //禁用错误报告 error_reporting(0); //报告运行时错误 error_reporting(E_ERROR | E_WARNING | E_PARSE); //报告所有错误 error_reporting(E_ALL); ?&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debian 7 64位编译php5 的注意点]]></title>
    <url>%2F2016%2F08%2F17%2F2016-2016-08-17-debian-7-php-64-error%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 debian 7 64位服务器由于lib路径的特殊性，编译php的时候，会一直抱某些lib文件找不到 比如libjpeg，libpng，libmysql等 其实我们只要用php的一个编译参数就可以解决这个问题，这个参数就是 –with-libdir= ./configure --prefix=/usr/local/php5 --with-iconv --with-zlib --enable-xml --with-gettext --with-curl --enable-force-cgi-redirect --enable-mbstring --with-mcrypt --with-gd --enable-gd-native-ttf --with-mhash --enable-sockets --with-xmlrpc --enable-zip --with-mysql --with-mysqli --with-pdo-mysql --enable-ftp --with-jpeg-dir --with-freetype-dir --with-png-dir --enable-bcmath --enable-calendar --enable-exif -with-openssl --with-bz2 --with-apxs2=/usr/local/apache2/bin/apxs --with-libdir=lib/x86_64-linux-gnu 注意 –with-libdir=lib/x86_64-linux-gnu 代表实际路径是 /usr/lib/x86_64-linux-gnu]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[phalcon 的跳转问题]]></title>
    <url>%2F2016%2F08%2F01%2F2016-2016-08-01-phalcon-redirect-send%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 今天又遇到那个那老问题了，phalcon 跳转（response-&gt;redirect(…)） 时，仍然会执行后续代码的问题 例1public function indexAction() { //判断条件 if(true){ $this-&gt;response-&gt;redirect(&apos;http://www.qq.com&apos;); } //new 一个 Phalcon\Logger\Adapter\File() , $logger = new File($this-&gt;config-&gt;application-&gt;logsDir.&apos;debug.log&apos;); // log $logger-&gt;log(&apos;hello world &apos;); } 执行该脚本，结果就是跳转到 www.qq.com ，但是 $logger 也仍然会运行，记录下 hello world。这种在action 的 redirect 还比较好解决，直接在 redirect 那里 return 就可以了 比如 public function indexAction() { //判断条件 if(true){ return $this-&gt;response-&gt;redirect(&apos;http://www.qq.com&apos;); //或者这样 $this-&gt;response-&gt;redirect(&apos;http://www.qq.com&apos;); return; } //new 一个 Phalcon\Logger\Adapter\File() , $logger = new File($this-&gt;config-&gt;application-&gt;logsDir.&apos;debug.log&apos;); // log $logger-&gt;log(&apos;hello world &apos;); } 但还有一种情况，就是比如判断用户权限时，就可会把 redirect 写在 initialize 或者 beforeExecuteRoute 等地方 public function initialize() { $this-&gt;response-&gt;redirect(&apos;http://www.baidu.com&apos;); return; } public function indexAction() { $this-&gt;response-&gt;redirect(&apos;http://www.qq.com&apos;); //new 一个 Phalcon\Logger\Adapter\File() , $logger = new File($this-&gt;config-&gt;application-&gt;logsDir.&apos;debug.log&apos;); // log $logger-&gt;log(&apos;hello world &apos;); } 执行后，就跳转到了 qq 而不是 baidu ， logger 也正常 log 。而且 initialize 里面的加了 return 也没有效果。 但是，如果把 return 改成exit 的话，就直接是空页面。 查了一下 Response 的接口，发现里面的两个方法 /** * Prints out HTTP response to the client * * @return ResponseInterface */ public function send(); /** * Sends headers to the client * * @return ResponseInterface */ public function sendHeaders(); 觉得可能 Response 只是设置了跳转url ，而实际并没有发送header。于是尝试了一下,在 redirect 方法后面加了 send() 或者 sendHeaders() 执行了一下。结果还是不成功，仍然会执行后续代码。再然后，加了一个exit ，就成功了。记录一下代码！！！ public function initialize() { //$this-&gt;response-&gt;redirect(&apos;http://www.baidu.com&apos;)-&gt;sendHeaders(); $this-&gt;response-&gt;redirect(&apos;http://www.baidu.com&apos;)-&gt;send(); exit(); } public function indexAction() { $this-&gt;response-&gt;redirect(&apos;http://www.qq.com&apos;); //new 一个 Phalcon\Logger\Adapter\File() , $logger = new File($this-&gt;config-&gt;application-&gt;logsDir.&apos;debug.log&apos;); // log $logger-&gt;log(&apos;hello world &apos;); } 上面的 send() 和 sendHeaders() 都可以用，关于这两个的区别，暂时没有时间研究。先记在这里吧，有时间再看！]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>phalcon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 新用户不能tab自动补全、退格变^H 等问题]]></title>
    <url>%2F2016%2F07%2F29%2F2016-2016-07-29-linux-new-user%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 去年搞了台国外的便宜的服务器，主要用于浏览长城以外的风光。服务器也一直很稳定。 由于硬盘空间较小，也没有准备搞其它用。最近决定在服务器上搞一些不占空间的服务，我草，每个访问一个页面，后面都带一段js代码。 然后试了一下，就连这最简单的 “echo ‘hello world’;” 都会带。google 了一下，没找到原因，然后就一言不合的重装了系统。。。 然后新建用户，切换过后发现新用户有问题。比如退格键是 ^H ，tab键不自动补全。。。 用命令看了一下 cat /ect/passwd 发现root用户的shell是/bin/bash 普通用户的shell是/bin/sh 然后把该用户的 /bin/sh 改成 /bin/bash 就行了]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux (debian) 启动报错 contains a file system with errors.check forced]]></title>
    <url>%2F2016%2F06%2F28%2F2016-2016-06-28-linux-contains-a-file%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 今天开机，debian起动不了了。搜索了一下，应该硬盘的逻辑卷无法加载。用 fsck 命令解决，特此记录fsck -C fd -N /dev/sda[n] #命令中 [n] 为出错的分区，一般为 /boot 分区 结果为 [/sbinfsck.ext4 (1) – /dev/sda[n] ] …… 然后执行命令 fsck.ext4 -C0 /dev/sda[n] 期间会多次地提示输入 yes/y 直接输入y 就行了。 完成后，会提示FILE SYSTEM WAS MODIFIED 不出意外，重启系统后就能成功登录了]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown初步尝试]]></title>
    <url>%2F2016%2F06%2F18%2F2016-2016-06-18-mark-down-learn%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 1. 一、 Title Title1= 通过在文字下方添加“=”表示一级标题。 Title1 = Title2- 通过在文字下方添加“-”表示二级标题。 Title2 - Title3 在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大） ### Title3 二、 有序列表使用数字后面跟上句号。（还要有空格）如：以下列表 小红 小明 小白 小逼 . 1. 小红 2. 小明 3. 小白 4. 小逼 三、无序列表在文字开头添加(*, +, -)和空格实现无序列表。 小红 小黄 小马 小羊 小高 小美 . - 小红 - 小黄 * 小马 * 小羊 + 小高 + 小美 四、加粗，斜体在文字开头和结尾加上 ** 这是加粗的文字1这是加粗的文字2 这是斜体文字1这是斜体文字2 . **这是加粗的文字1** __这是加粗的文字2__ *这是斜体文字1* _这是斜体文字2_ 五、图片 . ![这是一张图片](http://www.iconpng.com/png/phuzion/windows.png) 六、文字链接 普通跳转 Github . [Github](https://github.com/) target=’_blank’跳转 Github target _blank{:target=”_blank”} . [Github](https://github.com/){:target=&quot;_blank&quot;} 邮箱链接 &#x32;&#x38;&#52;&#49;&#x34;&#49;&#48;&#x35;&#48;&#x40;&#113;&#113;&#x2e;&#x63;&#x6f;&#x6d; . &lt;284141050@qq.com&gt; 七、引用 这是一个引用这是一个引用这是一个引用 这是另一个引用，&gt;后面有5个空格 这是另一个引用，&gt;后面有5个空格 这是另一个引用，&gt;后面有5个空格 . &gt; 这是一个引用 &gt; 这是一个引用 &gt; 这是一个引用 &gt; 这是另一个引用，&gt;后面有5个空格 &gt; 这是另一个引用，&gt;后面有5个空格 &gt; 这是另一个引用，&gt;后面有5个空格 八、删除线是不是有删除线 ~~是不是有删除线~~ 九、分割线**** --- 十、表格表1 姓名|性别|年龄|爱好小红|女|28|没有小明|男|21|考试Jim Green|男|25|打飞机 表2 姓名|性别|年龄|爱好|—|:—:|:—|—:|小红|女|28|没有小明|男|21|考试Jim Green|男|25|打飞机 表3 姓名|性别|年龄|爱好|— |— |— |— |小红|女|28|没有小明|男|21|考试Jim Green|男|25|打飞机 表1 姓名|性别|年龄|爱好 小红|女|28|没有 小明|男|21|考试 Jim Green|男|25|打飞机 表2 姓名|性别|年龄|爱好 |---|:---:|:---|---:| 小红|女|28|没有 小明|男|21|考试 Jim Green|男|25|打飞机 表3 姓名|性别|年龄|爱好 |--- |--- |--- |--- | 小红|女|28|没有 小明|男|21|考试 Jim Green|男|25|打飞机 sddff]]></content>
      <categories>
        <category>lessons</category>
      </categories>
      <tags>
        <tag>md</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在github等开源网站收集前端框架]]></title>
    <url>%2F2016%2F05%2F11%2F2016-2016-05-11-collect-github-frontend-source%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 GitHub1. BlackrockDigital 该大神估计是个前端狂，写了很多基于bootstrap 的前端框架，包括sb-admin 等。 startbootstrap-sb-admin-2 startbootstrap-clean-blog 2. almasaeed2010 AdminLte]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>frontend</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收集一些cdn公共库]]></title>
    <url>%2F2016%2F03%2F01%2F2016-2016-03-01-collect-cdn-source%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 国内： 百度cdn 七牛cdn bootstrap中国 cdnjs.net]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>cdn</tag>
        <tag>js</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node初学者入门，一本全面的NodeJS教程]]></title>
    <url>%2F2015%2F12%2F05%2F2015-2015-12-05-node-js-learn%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 关于本书致力于教会你如何用Node.js来开发应用，过程中会传授你所有所需的“高级”JavaScript知识。本书绝不是一本“Hello World”的教程。 状态你正在阅读的已经是本书的最终版。因此，只有当进行错误更正以及针对新版本Node.js的改动进行对应的修正时，才会进行更新。 本书中的代码案例都在Node.js 0.6.11版本中测试过，可以正确工作。 读者对象本书最适合与我有相似技术背景的读者： 至少对一门诸如Ruby、Python、PHP或者Java这样面向对象的语言有一定的经验；对JavaScript处于初学阶段，并且完全是一个Node.js的新手。 这里指的适合对其他编程语言有一定经验的开发者，意思是说，本书不会对诸如数据类型、变量、控制结构等等之类非常基础的概念作介绍。要读懂本书，这些基础的概念我都默认你已经会了。 然而，本书还是会对JavaScript中的函数和对象作详细介绍，因为它们与其他同类编程语言中的函数和对象有很大的不同。 本书结构读完本书之后，你将完成一个完整的web应用，该应用允许用户浏览页面以及上传文件。 当然了，应用本身并没有什么了不起的，相比为了实现该功能书写的代码本身，我们更关注的是如何创建一个框架来对我们应用的不同模块进行干净地剥离。 是不是很玄乎？稍后你就明白了。 本书先从介绍在Node.js环境中进行JavaScript开发和在浏览器环境中进行JavaScript开发的差异开始。 紧接着，会带领大家完成一个最传统的“Hello World”应用，这也是最基础的Node.js应用。 最后，会和大家讨论如何设计一个“真正”完整的应用，剖析要完成该应用需要实现的不同模块，并一步一步介绍如何来实现这些模块。 可以确保的是，在这过程中，大家会学到JavaScript中一些高级的概念、如何使用它们以及为什么使用这些概念就可以实现而其他编程语言中同类的概念就无法实现。 该应用所有的源代码都可以通过 本书Github代码仓库. 目录 关于 状态 读者对象 本书结构 JavaScript与Node.js JavaScript与你 简短申明 服务器端JavaScript “Hello World” 一个完整的基于Node.js的web应用 用例 应用不同模块分析 构建应用的模块 处理POST请求 处理文件上传 不好的实现方式 阻塞与非阻塞 以非阻塞操作进行请求响应 一个基础的HTTP服务器 分析HTTP服务器 进行函数传递 函数传递是如何让HTTP服务器工作的 基于事件驱动的回调 服务器是如何处理请求的 服务端的模块放在哪里 如何来进行请求的“路由” 行为驱动执行 路由给真正的请求处理程序 让请求处理程序作出响应 更有用的场景 总结与展望 JavaScript与Node.jsJavaScript与你抛开技术，我们先来聊聊你以及你和JavaScript的关系。本章的主要目的是想让你看看，对你而言是否有必要继续阅读后续章节的内容。 如果你和我一样，那么你很早就开始利用HTML进行“开发”，正因如此，你接触到了这个叫JavaScript有趣的东西，而对于JavaScript，你只会基本的操作——为web页面添加交互。 而你真正想要的是“干货”，你想要知道如何构建复杂的web站点 —— 于是，你学习了一种诸如PHP、Ruby、Java这样的编程语言，并开始书写“后端”代码。 与此同时，你还始终关注着JavaScript，随着通过一些对jQuery，Prototype之类技术的介绍，你慢慢了解到了很多JavaScript中的进阶技能，同时也感受到了JavaScript绝非仅仅是window.open() 那么简单。 . 不过，这些毕竟都是前端技术，尽管当想要增强页面的时候，使用jQuery总让你觉得很爽，但到最后，你顶多是个JavaScript用户，而非JavaScript开发者。 然后，出现了Node.js，服务端的JavaScript，这有多酷啊？ 于是，你觉得是时候该重新拾起既熟悉又陌生的JavaScript了。但是别急，写Node.js应用是一件事情；理解为什么它们要以它们书写的这种方式来书写则意味着——你要懂JavaScript。这次是玩真的了。 问题来了： 由于JavaScript真正意义上以两种，甚至可以说是三种形态存在（从中世纪90年代的作为对DHTML进行增强的小玩具，到像jQuery那样严格意义上的前端技术，一直到现在的服务端技术），因此，很难找到一个“正确”的方式来学习JavaScript，使得让你书写Node.js应用的时候感觉自己是在真正开发它而不仅仅是使用它。 因为这就是关键： 你本身已经是个有经验的开发者，你不想通过到处寻找各种解决方案（其中可能还有不正确的）来学习新的技术，你要确保自己是通过正确的方式来学习这项技术。 当然了，外面不乏很优秀的学习JavaScript的文章。但是，有的时候光靠那些文章是远远不够的。你需要的是指导。 本书的目标就是给你提供指导。 简短申明业界有非常优秀的JavaScript程序员。而我并非其中一员。 我就是上一节中描述的那个我。我熟悉如何开发后端web应用，但是对“真正”的JavaScript以及Node.js，我都只是新手。我也只是最近学习了一些JavaScript的高级概念，并没有实践经验。 因此，本书并不是一本“从入门到精通”的书，更像是一本“从初级入门到高级入门”的书。 如果成功的话，那么本书就是我当初开始学习Node.js最希望拥有的教程。 服务端JavaScriptJavaScript最早是运行在浏览器中，然而浏览器只是提供了一个上下文，它定义了使用JavaScript可以做什么，但并没有“说”太多关于JavaScript语言本身可以做什么。事实上，JavaScript是一门“完整”的语言： 它可以使用在不同的上下文中，其能力与其他同类语言相比有过之而无不及。 Node.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。 要实现在后台运行JavaScript代码，代码需要先被解释然后正确的执行。Node.js的原理正是如此，它使用了Google的V8虚拟机（Google的Chrome浏览器使用的JavaScript执行环境），来解释和执行JavaScript代码。 除此之外，伴随着Node.js的还有许多有用的模块，它们可以简化很多重复的劳作，比如向终端输出字符串。 因此，Node.js事实上既是一个运行时环境，同时又是一个库。 要使用Node.js,首先需要进行安装。关于如何安装Node.js，这里就不赘述了，可以直接参考官方的安装指南。安装完成后，继续回来阅读本书下面的内容。 “Hello World”好了，“废话”不多说了，马上开始我们第一个Node.js应用：“Hello World”。 打开你最喜欢的编辑器，创建一个helloworld.js文件。我们要做就是向STDOUT输出“Hello World”，如下是实现该功能的代码： console.log(&quot;Hello World&quot;); 保存该文件，并通过Node.js来执行： node helloworld.js 正常的话，就会在终端输出Hello World 。 好吧，我承认这个应用是有点无趣，那么下面我们就来点“干货”。 一个完整的基于Node.js的web应用用例我们来把目标设定得简单点，不过也要够实际才行： 用户可以通过浏览器使用我们的应用。 当用户请求http://domain/start时，可以看到一个欢迎页面，页面上有一个文件上传的表单。 用户可以选择一个图片并提交表单，随后文件将被上传到http://domain/upload，该页面完成上传后会把图片显示在页面上。 差不多了，你现在也可以去Google一下，找点东西乱搞一下来完成功能。但是我们现在先不做这个。 更进一步地说，在完成这一目标的过程中，我们不仅仅需要基础的代码而不管代码是否优雅。我们还要对此进行抽象，来寻找一种适合构建更为复杂的Node.js应用的方式。 应用不同模块分析我们来分解一下这个应用，为了实现上文的用例，我们需要实现哪些部分呢？ 我们需要提供Web页面，因此需要一个HTTP服务器 对于不同的请求，根据请求的URL，我们的服务器需要给予不同的响应，因此我们需要一个路由，用于把请求对应到请求处理程序（request handler） 当请求被服务器接收并通过路由传递之后，需要可以对其进行处理，因此我们需要最终的请求处理程序 路由还应该能处理POST数据，并且把数据封装成更友好的格式传递给请求处理入程序，因此需要请求数据处理功能 我们不仅仅要处理URL对应的请求，还要把内容显示出来，这意味着我们需要一些视图逻辑供请求处理程序使用，以便将内容发送给用户的浏览器 最后，用户需要上传图片，所以我们需要上传处理功能来处理这方面的细节 我们先来想想，使用PHP的话我们会怎么构建这个结构。一般来说我们会用一个Apache HTTP服务器并配上mod_php5模块。从这个角度看，整个“接收HTTP请求并提供Web页面”的需求根本不需要PHP来处理。 不过对Node.js来说，概念完全不一样了。使用Node.js时，我们不仅仅在实现一个应用，同时还实现了整个HTTP服务器。事实上，我们的Web应用以及对应的Web服务器基本上是一样的。 听起来好像有一大堆活要做，但随后我们会逐渐意识到，对Node.js来说这并不是什么麻烦的事。 现在我们就来开始实现之路，先从第一个部分–HTTP服务器着手。 构建应用的模块一个基础的HTTP服务器当我准备开始写我的第一个“真正的”Node.js应用的时候，我不但不知道怎么写Node.js代码，也不知道怎么组织这些代码。我应该把所有东西都放进一个文件里吗？网上有很多教程都会教你把所有的逻辑都放进一个用Node.js写的基础HTTP服务器里。但是如果我想加入更多的内容，同时还想保持代码的可读性呢？ 实际上，只要把不同功能的代码放入不同的模块中，保持代码分离还是相当简单的。 这种方法允许你拥有一个干净的主文件（main file），你可以用Node.js执行它；同时你可以拥有干净的模块，它们可以被主文件和其他的模块调用。 那么，现在我们来创建一个用于启动我们的应用的主文件，和一个保存着我们的HTTP服务器代码的模块。 在我的印象里，把主文件叫做index.js或多或少是个标准格式。把服务器模块放进叫server.js的文件里则很好理解。 让我们先从服务器模块开始。在你的项目的根目录下创建一个叫server.js的文件，并写入以下代码： var http = require(&quot;http&quot;); http.createServer(function(request, response) { response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(&quot;Hello World&quot;); response.end(); }).listen(8888); 搞定！你刚刚完成了一个可以工作的HTTP服务器。为了证明这一点，我们来运行并且测试这段代码。首先，用Node.js执行你的脚本： node server.js 接下来，打开浏览器访问http://localhost:8888/，你会看到一个写着“Hello World”的网页。 这很有趣，不是吗？让我们先来谈谈HTTP服务器的问题，把如何组织项目的事情先放一边吧，你觉得如何？我保证之后我们会解决那个问题的。 分析HTTP服务器那么接下来，让我们分析一下这个HTTP服务器的构成。 第一行请求（require）Node.js自带的 http 模块，并且把它赋值给 http 变量。 接下来我们调用http模块提供的函数： createServer 。这个函数会返回一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数，指定这个HTTP服务器监听的端口号。 咱们暂时先不管 http.createServer 的括号里的那个函数定义。 我们本来可以用这样的代码来启动服务器并侦听8888端口： var http = require(&quot;http&quot;); var server = http.createServer(); server.listen(8888); 这段代码只会启动一个侦听8888端口的服务器，它不做任何别的事情，甚至连请求都不会应答。 最有趣（而且，如果你之前习惯使用一个更加保守的语言，比如PHP，它还很奇怪）的部分是 createSever() 的第一个参数，一个函数定义。 实际上，这个函数定义是 createServer() 的第一个也是唯一一个参数。因为在JavaScript中，函数和其他变量一样都是可以被传递的。 进行函数传递举例来说，你可以这样做： function say(word) { console.log(word); } function execute(someFunction, value) { someFunction(value); } execute(say, &quot;Hello&quot;); 请仔细阅读这段代码！在这里，我们把 say 函数作为execute函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！ 这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。 当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。 我们可以，就像刚才那样，用它的名字把一个函数作为变量传递。但是我们不一定要绕这个“先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数： function execute(someFunction, value) { someFunction(value); } execute(function(word){ console.log(word) }, &quot;Hello&quot;); 我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。 用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做 匿名函数。 这是我们和我所认为的“进阶”JavaScript的第一次亲密接触，不过我们还是得循序渐进。现在，我们先接受这一点：在JavaScript中，一个函数可以作为另一个函数接收一个参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。 函数传递是如何让HTTP服务器工作的带着这些知识，我们再来看看我们简约而不简单的HTTP服务器： var http = require(“http”); http.createServer(function(request, response) { response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(&quot;Hello World&quot;); response.end(); }).listen(8888); 现在它看上去应该清晰了很多：我们向 createServer 函数传递了一个匿名函数。 用这样的代码也可以达到同样的目的： var http = require(&quot;http&quot;); function onRequest(request, response) { response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(&quot;Hello World&quot;); response.end(); } http.createServer(onRequest).listen(8888);也许现在我们该问这个问题了：我们为什么要用这种方式呢？ 基于事件驱动的回调这个问题可不好回答（至少对我来说），不过这是Node.js原生的工作方式。它是事件驱动的，这也是它为什么这么快的原因。 你也许会想花点时间读一下Felix Geisendörfer的大作Understanding node.js，它介绍了一些背景知识。 这一切都归结于“Node.js是事件驱动的”这一事实。好吧，其实我也不是特别确切的了解这句话的意思。不过我会试着解释，为什么它对我们用Node.js写网络应用（Web based application）是有意义的。 当我们使用 http.createServer 方法的时候，我们当然不只是想要一个侦听某个端口的服务器，我们还想要它在服务器收到一个HTTP请求的时候做点什么。 问题是，这是异步的：请求任何时候都可能到达，但是我们的服务器却跑在一个单进程中。 写PHP应用的时候，我们一点也不为此担心：任何时候当有请求进入的时候，网页服务器（通常是Apache）就为这一请求新建一个进程，并且开始从头到尾执行相应的PHP脚本。 那么在我们的Node.js程序中，当一个新的请求到达8888端口的时候，我们怎么控制流程呢？ 嗯，这就是Node.js/JavaScript的事件驱动设计能够真正帮上忙的地方了——虽然我们还得学一些新概念才能掌握它。让我们来看看这些概念是怎么应用在我们的服务器代码里的。 我们创建了服务器，并且向创建它的方法传递了一个函数。无论何时我们的服务器收到一个请求，这个函数就会被调用。 我们不知道这件事情什么时候会发生，但是我们现在有了一个处理请求的地方：它就是我们传递过去的那个函数。至于它是被预先定义的函数还是匿名函数，就无关紧要了。 这个就是传说中的 回调 。我们给某个方法传递了一个函数，这个方法在有相应事件发生时调用这个函数来进行 回调 。 至少对我来说，需要一些功夫才能弄懂它。你如果还是不太确定的话就再去读读Felix的博客文章。 让我们再来琢磨琢磨这个新概念。我们怎么证明，在创建完服务器之后，即使没有HTTP请求进来、我们的回调函数也没有被调用的情况下，我们的代码还继续有效呢？我们试试这个： var http = require(&quot;http&quot;); function onRequest(request, response) { console.log(&quot;Request received.&quot;); response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(&quot;Hello World&quot;); response.end(); } http.createServer(onRequest).listen(8888); console.log(&quot;Server has started.&quot;); 注意：在 onRequest （我们的回调函数）触发的地方，我用 console.log 输出了一段文本。在HTTP服务器开始工作之后，也输出一段文本。 当我们与往常一样，运行它node server.js时，它会马上在命令行上输出“Server has started.”。当我们向服务器发出请求（在浏览器访问http://localhost:8888/），“Request received.”这条消息就会在命令行中出现。 这就是事件驱动的异步服务器端JavaScript和它的回调啦！ （请注意，当我们在服务器访问网页时，我们的服务器可能会输出两次“Request received.”。那是因为大部分服务器都会在你访问 http://localhost:8888 /时尝试读取 http://localhost:8888/favicon.ico ) 服务器是如何处理请求的好的，接下来我们简单分析一下我们服务器代码中剩下的部分，也就是我们的回调函数 onRequest() 的主体部分。 当回调启动，我们的 onRequest() 函数被触发的时候，有两个参数被传入：request 和 response 。 它们是对象，你可以使用它们的方法来处理HTTP请求的细节，并且响应请求（比如向发出请求的浏览器发回一些东西）。 所以我们的代码就是：当收到请求时，使用 response.writeHead() 函数发送一个HTTP状态200和HTTP头的内容类型（content-type），使用 response.write() 函数在HTTP相应主体中发送文本“Hello World”。 最后，我们调用 response.end() 完成响应。 目前来说，我们对请求的细节并不在意，所以我们没有使用 request 对象。 服务端的模块放在哪里OK，就像我保证过的那样，我们现在可以回到我们如何组织应用这个问题上了。我们现在在 server.js 文件中有一个非常基础的HTTP服务器代码，而且我提到通常我们会有一个叫 index.js 的文件去调用应用的其他模块（比如 server.js 中的HTTP服务器模块）来引导和启动应用。 我们现在就来谈谈怎么把server.js变成一个真正的Node.js模块，使它可以被我们（还没动工）的 index.js 主文件使用。 也许你已经注意到，我们已经在代码中使用了模块了。像这样： var http = require(&quot;http&quot;); ... http.createServer(...); Node.js中自带了一个叫做“http”的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。 这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。 给这种本地变量起一个和模块名称一样的名字是一种惯例，但是你也可以按照自己的喜好来： var foo = require(&quot;http&quot;); ... foo.createServer(...); 很好，怎么使用Node.js内部模块已经很清楚了。我们怎么创建自己的模块，又怎么使用它呢？ 等我们把 server.js 变成一个真正的模块，你就能搞明白了。 事实上，我们不用做太多的修改。把某段代码变成模块意味着我们需要把我们希望提供其功能的部分 导出 到请求这个模块的脚本。 目前，我们的HTTP服务器需要导出的功能非常简单，因为请求服务器模块的脚本仅仅是需要启动服务器而已。 我们把我们的服务器脚本放到一个叫做 start 的函数里，然后我们会导出这个函数。 var http = require(&quot;http&quot;); function start() { function onRequest(request, response) { console.log(&quot;Request received.&quot;); response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(&quot;Hello World&quot;); response.end(); } http.createServer(onRequest).listen(8888); console.log(&quot;Server has started.&quot;); } exports.start = start; 这样，我们现在就可以创建我们的主文件 index.js 并在其中启动我们的HTTP了，虽然服务器的代码还在 server.js 中。 创建 index.js 文件并写入以下内容： var server = require(&quot;./server&quot;); server.start(); 正如你所看到的，我们可以像使用任何其他的内置模块一样使用server模块：请求这个文件并把它指向一个变量，其中已导出的函数就可以被我们使用了。 好了。我们现在就可以从我们的主要脚本启动我们的的应用了，而它还是老样子： node index.js 非常好，我们现在可以把我们的应用的不同部分放入不同的文件里，并且通过生成模块的方式把它们连接到一起了。 我们仍然只拥有整个应用的最初部分：我们可以接收HTTP请求。但是我们得做点什么——对于不同的URL请求，服务器应该有不同的反应。 对于一个非常简单的应用来说，你可以直接在回调函数 onRequest() 中做这件事情。不过就像我说过的，我们应该加入一些抽象的元素，让我们的例子变得更有趣一点儿。 处理不同的HTTP请求在我们的代码中是一个不同的部分，叫做“路由选择”——那么，我们接下来就创造一个叫做 路由 的模块吧。 如何来进行请求的“路由”我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码（这里“代码”对应整个应用的第三部分：一系列在接收到请求时真正工作的处理程序）。 因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。 我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是url和querystring模块。 url.parse(string).query | url.parse(string).pathname | | | | | ------ ------------------- http://localhost:8888/start?foo=bar&amp;hello=world --- ----- | | | | querystring(string)[&quot;foo&quot;] | | querystring(string)[&quot;hello&quot;] 当然我们也可以用querystring模块来解析POST请求体中的参数，稍后会有演示。 现在我们来给onRequest()函数加上一些逻辑，用来找出浏览器请求的URL路径： var http = require(&quot;http&quot;); var url = require(&quot;url&quot;); function start() { function onRequest(request, response) { var pathname = url.parse(request.url).pathname; console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;); response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(&quot;Hello World&quot;); response.end(); } http.createServer(onRequest).listen(8888); console.log(&quot;Server has started.&quot;); } exports.start = start; 好了，我们的应用现在可以通过请求的URL路径来区别不同请求了–这使我们得以使用路由（还未完成）来将请求以URL路径为基准映射到处理程序上。 在我们所要构建的应用中，这意味着来自/start和/upload的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。 现在我们可以来编写路由了，建立一个名为router.js的文件，添加以下内容： function route(pathname) { console.log(&quot;About to route a request for &quot; + pathname); } exports.route = route; 如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。 我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块（你可以读读Martin Fowlers关于依赖注入的大作来作为背景知识）。 首先，我们来扩展一下服务器的start()函数，以便将路由函数作为参数传递过去： var http = require(&quot;http&quot;); var url = require(&quot;url&quot;); function start(route) { function onRequest(request, response) { var pathname = url.parse(request.url).pathname; console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;); route(pathname); response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(&quot;Hello World&quot;); response.end(); } http.createServer(onRequest).listen(8888); console.log(&quot;Server has started.&quot;); } exports.start = start; 同时，我们会相应扩展index.js，使得路由函数可以被注入到服务器中： var server = require(&quot;./server&quot;); var router = require(&quot;./router&quot;); server.start(router.route); 在这里，我们传递的函数依旧什么也没做。 如果现在启动应用（node index.js，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由： bash$ node index.js Request for /foo received. About to route a request for /foo （以上输出已经去掉了比较烦人的/favicon.ico请求相关的部分）。 行为驱动执行请允许我再次脱离主题，在这里谈一谈函数式编程。 将函数作为参数传递并不仅仅出于技术上的考量。对软件设计来说，这其实是个哲学问题。想想这样的场景：在index文件中，我们可以将router对象传递进去，服务器随后可以调用这个对象的route函数。 就像这样，我们传递一个东西，然后服务器利用这个东西来完成一些事。嗨那个叫路由的东西，能帮我把这个路由一下吗？ 但是服务器其实不需要这样的东西。它只需要把事情做完就行，其实为了把事情做完，你根本不需要东西，你需要的是动作。也就是说，你不需要名词，你需要动词。 理解了这个概念里最核心、最基本的思想转换后，我自然而然地理解了函数编程。 我是在读了Steve Yegge的大作名词王国中的死刑之后理解函数编程。你也去读一读这本书吧，真的。这是曾给予我阅读的快乐的关于软件的书籍之一。 路由给真正的请求处理程序回到正题，现在我们的HTTP服务器和请求路由模块已经如我们的期望，可以相互交流了，就像一对亲密无间的兄弟。 当然这还远远不够，路由，顾名思义，是指我们要针对不同的URL有不同的处理方式。例如处理/start的“业务逻辑”就应该和处理/upload的不同。 在现在的实现下，路由过程会在路由模块中“结束”，并且路由模块并不是真正针对请求“采取行动”的模块，否则当我们的应用程序变得更为复杂时，将无法很好地扩展。 我们暂时把作为路由目标的函数称为请求处理程序。现在我们不要急着来开发路由模块，因为如果请求处理程序没有就绪的话，再怎么完善路由模块也没有多大意义。 应用程序需要新的部件，因此加入新的模块 – 已经无需为此感到新奇了。我们来创建一个叫做requestHandlers的模块，并对于每一个请求处理程序，添加一个占位用函数，随后将这些函数作为模块的方法导出： function start() { console.log(&quot;Request handler &apos;start&apos; was called.&quot;); } function upload() { console.log(&quot;Request handler &apos;upload&apos; was called.&quot;); } exports.start = start; exports.upload = upload; 这样我们就可以把请求处理程序和路由模块连接起来，让路由“有路可寻”。 在这里我们得做个决定：是将requestHandlers模块硬编码到路由里来使用，还是再添加一点依赖注入？虽然和其他模式一样，依赖注入不应该仅仅为使用而使用，但在现在这个情况下，使用依赖注入可以让路由和请求处理程序之间的耦合更加松散，也因此能让路由的重用性更高。 这意味着我们得将请求处理程序从服务器传递到路由中，但感觉上这么做更离谱了，我们得一路把这堆请求处理程序从我们的主文件传递到服务器中，再将之从服务器传递到路由。 那么我们要怎么传递这些请求处理程序呢？别看现在我们只有2个处理程序，在一个真实的应用中，请求处理程序的数量会不断增加，我们当然不想每次有一个新的URL或请求处理程序时，都要为了在路由里完成请求到处理程序的映射而反复折腾。除此之外，在路由里有一大堆if request == x then call handler y也使得系统丑陋不堪。 仔细想想，有一大堆东西，每个都要映射到一个字符串（就是请求的URL）上？似乎关联数组（associative array）能完美胜任。 不过结果有点令人失望，JavaScript没提供关联数组 – 也可以说它提供了？事实上，在JavaScript中，真正能提供此类功能的是它的对象。 在这方面，http://msdn.microsoft.com/en-us/magazine/cc163419.aspx有一个不错的介绍，我在此摘录一段： 在C++或C#中，当我们谈到对象，指的是类或者结构体的实例。对象根据他们实例化的模板（就是所谓的类），会拥有不同的属性和方法。但在JavaScript里对象不是这个概念。在JavaScript中，对象就是一个键/值对的集合 – 你可以把JavaScript的对象想象成一个键为字符串类型的字典。 但如果JavaScript的对象仅仅是键/值对的集合，它又怎么会拥有方法呢？好吧，这里的值可以是字符串、数字或者……函数！ 好了，最后再回到代码上来。现在我们已经确定将一系列请求处理程序通过一个对象来传递，并且需要使用松耦合的方式将这个对象注入到route()函数中。 我们先将这个对象引入到主文件index.js中： var server = require(&quot;./server&quot;); var router = require(&quot;./router&quot;); var requestHandlers = require(&quot;./requestHandlers&quot;); var handle = {} handle[&quot;/&quot;] = requestHandlers.start; handle[&quot;/start&quot;] = requestHandlers.start; handle[&quot;/upload&quot;] = requestHandlers.upload; server.start(router.route, handle); 虽然handle并不仅仅是一个“东西”（一些请求处理程序的集合），我还是建议以一个动词作为其命名，这样做可以让我们在路由中使用更流畅的表达式，稍后会有说明。 正如所见，将不同的URL映射到相同的请求处理程序上是很容易的：只要在对象中添加一个键为”/“的属性，对应requestHandlers.start即可，这样我们就可以干净简洁地配置/start和/的请求都交由start这一处理程序处理。 在完成了对象的定义后，我们把它作为额外的参数传递给服务器，为此将server.js修改如下： var http = require(&quot;http&quot;); var url = require(&quot;url&quot;); function start(route, handle) { function onRequest(request, response) { var pathname = url.parse(request.url).pathname; console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;); route(handle, pathname); response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(&quot;Hello World&quot;); response.end(); } http.createServer(onRequest).listen(8888); console.log(&quot;Server has started.&quot;); } exports.start = start; 这样我们就在start()函数里添加了handle参数，并且把handle对象作为第一个参数传递给了route()回调函数。 然后我们相应地在route.js文件中修改route()函数： function route(handle, pathname) { console.log(&quot;About to route a request for &quot; + pathname); if (typeof handle[pathname] === &apos;function&apos;) { handle[pathname](); } else { console.log(&quot;No request handler found for &quot; + pathname); } } exports.route = route; 通过以上代码，我们首先检查给定的路径对应的请求处理程序是否存在，如果存在的话直接调用相应的函数。我们可以用从关联数组中获取元素一样的方式从传递的对象中获取请求处理函数，因此就有了简洁流畅的形如handlepathname;的表达式，这个感觉就像在前方中提到的那样：“嗨，请帮我处理了这个路径”。 有了这些，我们就把服务器、路由和请求处理程序在一起了。现在我们启动应用程序并在浏览器中访问http://localhost:8888/start，以下日志可以说明系统调用了正确的请求处理程序： Server has started. Request for /start received. About to route a request for /start Request handler &apos;start&apos; was called. 并且在浏览器中打开http://localhost:8888/可以看到这个请求同样被start请求处理程序处理了： Request for / received. About to route a request for / Request handler &apos;start&apos; was called. 让请求处理程序作出响应 很好。不过现在要是请求处理程序能够向浏览器返回一些有意义的信息而并非全是“Hello World”，那就更好了。 这里要记住的是，浏览器发出请求后获得并显示的“Hello World”信息仍是来自于我们server.js文件中的onRequest函数。 其实“处理请求”说白了就是“对请求作出响应”，因此，我们需要让请求处理程序能够像onRequest函数那样可以和浏览器进行“对话”。 不好的实现方式对于我们这样拥有PHP或者Ruby技术背景的开发者来说，最直截了当的实现方式事实上并不是非常靠谱： 看似有效，实则未必如此。 这里我指的“直截了当的实现方式”意思是：让请求处理程序通过onRequest函数直接返回（return()）他们要展示给用户的信息。 我们先就这样去实现，然后再来看为什么这不是一种很好的实现方式。 让我们从让请求处理程序返回需要在浏览器中显示的信息开始。我们需要将requestHandler.js修改为如下形式： function start() { console.log(&quot;Request handler &apos;start&apos; was called.&quot;); return &quot;Hello Start&quot;; } function upload() { console.log(&quot;Request handler &apos;upload&apos; was called.&quot;); return &quot;Hello Upload&quot;; } exports.start = start; exports.upload = upload; 好的。同样的，请求路由需要将请求处理程序返回给它的信息返回给服务器。因此，我们需要将router.js修改为如下形式： function route(handle, pathname) { console.log(&quot;About to route a request for &quot; + pathname); if (typeof handle[pathname] === &apos;function&apos;) { return handle[pathname](); } else { console.log(&quot;No request handler found for &quot; + pathname); return &quot;404 Not found&quot;; } } exports.route = route; 正如上述代码所示，当请求无法路由的时候，我们也返回了一些相关的错误信息。 最后，我们需要对我们的server.js进行重构以使得它能够将请求处理程序通过请求路由返回的内容响应给浏览器，如下所示： var http = require(&quot;http&quot;); var url = require(&quot;url&quot;); function start(route, handle) { function onRequest(request, response) { var pathname = url.parse(request.url).pathname; console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;); response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); var content = route(handle, pathname) response.write(content); response.end(); } http.createServer(onRequest).listen(8888); console.log(&quot;Server has started.&quot;); } exports.start = start; 如果我们运行重构后的应用，一切都会工作的很好：请求http://localhost:8888/start,浏览器会输出“Hello Start”，请求http://localhost:8888/upload会输出“Hello Upload”,而请求http://localhost:8888/foo 会输出“404 Not found”。 好，那么问题在哪里呢？简单的说就是： 当未来有请求处理程序需要进行非阻塞的操作的时候，我们的应用就“挂”了。 没理解？没关系，下面就来详细解释下。 阻塞与非阻塞正如此前所提到的，当在请求处理程序中包括非阻塞操作时就会出问题。但是，在说这之前，我们先来看看什么是阻塞操作。 我不想去解释“阻塞”和“非阻塞”的具体含义，我们直接来看，当在请求处理程序中加入阻塞操作时会发生什么。 这里，我们来修改下start请求处理程序，我们让它等待10秒以后再返回“Hello Start”。因为，JavaScript中没有类似sleep()这样的操作，所以这里只能够来点小Hack来模拟实现。 让我们将requestHandlers.js修改成如下形式： function start() { console.log(&quot;Request handler &apos;start&apos; was called.&quot;); function sleep(milliSeconds) { var startTime = new Date().getTime(); while (new Date().getTime() &lt; startTime + milliSeconds); } sleep(10000); return &quot;Hello Start&quot;; } function upload() { console.log(&quot;Request handler &apos;upload&apos; was called.&quot;); return &quot;Hello Upload&quot;; } exports.start = start; exports.upload = upload; 上述代码中，当函数start()被调用的时候，Node.js会先等待10秒，之后才会返回“Hello Start”。当调用upload()的时候，会和此前一样立即返回。 （当然了，这里只是模拟休眠10秒，实际场景中，这样的阻塞操作有很多，比方说一些长时间的计算操作等。） 接下来就让我们来看看，我们的改动带来了哪些变化。 如往常一样，我们先要重启下服务器。为了看到效果，我们要进行一些相对复杂的操作（跟着我一起做）： 首先，打开两个浏览器窗口或者标签页。在第一个浏览器窗口的地址栏中输入http://localhost:8888/start， 但是先不要打开它！ 在第二个浏览器窗口的地址栏中输入http://localhost:8888/upload， 同样的，先不要打开它！ 接下来，做如下操作：在第一个窗口中（“/start”）按下回车，然后快速切换到第二个窗口中（“/upload”）按下回车。 注意，发生了什么： /start URL加载花了10秒，这和我们预期的一样。但是，/upload URL居然也花了10秒，而它在对应的请求处理程序中并没有类似于sleep()这样的操作！ 这到底是为什么呢？原因就是start()包含了阻塞操作。形象的说就是“它阻塞了所有其他的处理工作”。 这显然是个问题，因为Node一向是这样来标榜自己的：“在node中除了代码，所有一切都是并行执行的”。 这句话的意思是说，Node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理 —— Node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，对此，我们应该要充分利用这一点 —— 尽可能的避免阻塞操作，取而代之，多使用非阻塞操作。 然而，要用非阻塞操作，我们需要使用回调，通过将函数作为参数传递给其他需要花时间做处理的函数（比方说，休眠10秒，或者查询数据库，又或者是进行大量的计算）。 对于Node.js来说，它是这样处理的：“嘿，probablyExpensiveFunction()（译者注：这里指的就是需要花时间处理的函数），你继续处理你的事情，我（Node.js线程）先不等你了，我继续去处理你后面的代码，请你提供一个callbackFunction()，等你处理完之后我会去调用该回调函数的，谢谢！” （如果想要了解更多关于事件轮询细节，可以阅读Mixu的博文——理解node.js的事件轮询。） 接下来，我们会介绍一种错误的使用非阻塞操作的方式。 和上次一样，我们通过修改我们的应用来暴露问题。 这次我们还是拿start请求处理程序来“开刀”。将其修改成如下形式： var exec = require(&quot;child_process&quot;).exec; function start() { console.log(&quot;Request handler &apos;start&apos; was called.&quot;); var content = &quot;empty&quot;; exec(&quot;ls -lah&quot;, function (error, stdout, stderr) { content = stdout; }); return content; } function upload() { console.log(&quot;Request handler &apos;upload&apos; was called.&quot;); return &quot;Hello Upload&quot;; } exports.start = start; exports.upload = upload; 上述代码中，我们引入了一个新的Node.js模块，child_process。之所以用它，是为了实现一个既简单又实用的非阻塞操作：exec()。 exec()做了什么呢？它从Node.js来执行一个shell命令。在上述例子中，我们用它来获取当前目录下所有的文件（“ls -lah”）,然后，当/startURL请求的时候将文件信息输出到浏览器中。 上述代码是非常直观的： 创建了一个新的变量content（初始值为“empty”），执行“ls -lah”命令，将结果赋值给content，最后将content返回。 和往常一样，我们启动服务器，然后访问“http://localhost:8888/start” 。 之后会载入一个漂亮的web页面，其内容为“empty”。怎么回事？ 这个时候，你可能大致已经猜到了，exec()在非阻塞这块发挥了神奇的功效。它其实是个很好的东西，有了它，我们可以执行非常耗时的shell操作而无需迫使我们的应用停下来等待该操作。 （如果想要证明这一点，可以将“ls -lah”换成比如“find /”这样更耗时的操作来效果）。 然而，针对浏览器显示的结果来看，我们并不满意我们的非阻塞操作，对吧？ 好，接下来，我们来修正这个问题。在这过程中，让我们先来看看为什么当前的这种方式不起作用。 问题就在于，为了进行非阻塞工作，exec()使用了回调函数。 在我们的例子中，该回调函数就是作为第二个参数传递给exec()的匿名函数： function (error, stdout, stderr) { content = stdout; } 现在就到了问题根源所在了：我们的代码是同步执行的，这就意味着在调用exec()之后，Node.js会立即执行 return content ；在这个时候，content仍然是“empty”，因为传递给exec()的回调函数还未执行到——因为exec()的操作是异步的。 我们这里“ls -lah”的操作其实是非常快的（除非当前目录下有上百万个文件）。这也是为什么回调函数也会很快的执行到 —— 不过，不管怎么说它还是异步的。 为了让效果更加明显，我们想象一个更耗时的命令： “find /”，它在我机器上需要执行1分钟左右的时间，然而，尽管在请求处理程序中，我把“ls -lah”换成“find /”，当打开/start URL的时候，依然能够立即获得HTTP响应 —— 很明显，当exec()在后台执行的时候，Node.js自身会继续执行后面的代码。并且我们这里假设传递给exec()的回调函数，只会在“find /”命令执行完成之后才会被调用。 那究竟我们要如何才能实现将当前目录下的文件列表显示给用户呢？ 好，了解了这种不好的实现方式之后，我们接下来来介绍如何以正确的方式让请求处理程序对浏览器请求作出响应。 以非阻塞操作进行请求响应 我刚刚提到了这样一个短语 —— “正确的方式”。而事实上通常“正确的方式”一般都不简单。 不过，用Node.js就有这样一种实现方案： 函数传递。下面就让我们来具体看看如何实现。 到目前为止，我们的应用已经可以通过应用各层之间传递值的方式（请求处理程序 -&gt; 请求路由 -&gt; 服务器）将请求处理程序返回的内容（请求处理程序最终要显示给用户的内容）传递给HTTP服务器。 现在我们采用如下这种新的实现方式：相对采用将内容传递给服务器的方式，我们这次采用将服务器“传递”给内容的方式。 从实践角度来说，就是将response对象（从服务器的回调函数onRequest()获取）通过请求路由传递给请求处理程序。 随后，处理程序就可以采用该对象上的函数来对请求作出响应。 原理就是如此，接下来让我们来一步步实现这种方案。 先从server.js开始： var http = require(&quot;http&quot;); var url = require(&quot;url&quot;); function start(route, handle) { function onRequest(request, response) { var pathname = url.parse(request.url).pathname; console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;); route(handle, pathname, response); } http.createServer(onRequest).listen(8888); console.log(&quot;Server has started.&quot;); } exports.start = start; 相对此前从route()函数获取返回值的做法，这次我们将response对象作为第三个参数传递给route()函数，并且，我们将onRequest()处理程序中所有有关response的函数调都移除，因为我们希望这部分工作让route()函数来完成。 下面就来看看我们的router.js: function route(handle, pathname, response) { console.log(&quot;About to route a request for &quot; + pathname); if (typeof handle[pathname] === &apos;function&apos;) { handle[pathname](response); } else { console.log(&quot;No request handler found for &quot; + pathname); response.writeHead(404, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(&quot;404 Not found&quot;); response.end(); } } exports.route = route; 同样的模式：相对此前从请求处理程序中获取返回值，这次取而代之的是直接传递response对象。 如果没有对应的请求处理器处理，我们就直接返回“404”错误。 最后，我们将requestHandler.js修改为如下形式： var exec = require(&quot;child_process&quot;).exec; function start(response) { console.log(&quot;Request handler &apos;start&apos; was called.&quot;); exec(&quot;ls -lah&quot;, function (error, stdout, stderr) { response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(stdout); response.end(); }); } function upload(response) { console.log(&quot;Request handler &apos;upload&apos; was called.&quot;); response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(&quot;Hello Upload&quot;); response.end(); } exports.start = start; exports.upload = upload; 我们的处理程序函数需要接收response参数，为了对请求作出直接的响应。 start处理程序在exec()的匿名回调函数中做请求响应的操作，而upload处理程序仍然是简单的回复“Hello World”，只是这次是使用response对象而已。 这时再次我们启动应用（node index.js），一切都会工作的很好。 如果想要证明/start处理程序中耗时的操作不会阻塞对/upload请求作出立即响应的话，可以将requestHandlers.js修改为如下形式： var exec = require(&quot;child_process&quot;).exec; function start(response) { console.log(&quot;Request handler &apos;start&apos; was called.&quot;); exec(&quot;find /&quot;, { timeout: 10000, maxBuffer: 20000*1024 }, function (error, stdout, stderr) { response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(stdout); response.end(); }); } function upload(response) { console.log(&quot;Request handler &apos;upload&apos; was called.&quot;); response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(&quot;Hello Upload&quot;); response.end(); } exports.start = start; exports.upload = upload; 这样一来，当请求http://localhost:8888/start的时候，会花10秒钟的时间才载入，而当请求http://localhost:8888/upload的时候，会立即响应，纵然这个时候/start响应还在处理中。 更有用的场景 到目前为止，我们做的已经很好了，但是，我们的应用没有实际用途。 服务器，请求路由以及请求处理程序都已经完成了，下面让我们按照此前的用例给网站添加交互：用户选择一个文件，上传该文件，然后在浏览器中看到上传的文件。 为了保持简单，我们假设用户只会上传图片，然后我们应用将该图片显示到浏览器中。 好，下面就一步步来实现，鉴于此前已经对JavaScript原理性技术性的内容做过大量介绍了，这次我们加快点速度。 要实现该功能，分为如下两步： 首先，让我们来看看如何处理POST请求（非文件上传），之后，我们使用Node.js的一个用于文件上传的外部模块。之所以采用这种实现方式有两个理由。 第一，尽管在Node.js中处理基础的POST请求相对比较简单，但在这过程中还是能学到很多。第二，用Node.js来处理文件上传（multipart POST请求）是比较复杂的，它不在本书的范畴，但，如何使用外部模块却是在本书涉猎内容之内。 处理POST请求 考虑这样一个简单的例子：我们显示一个文本区（textarea）供用户输入内容，然后通过POST请求提交给服务器。最后，服务器接受到请求，通过处理程序将输入的内容展示到浏览器中。 /start请求处理程序用于生成带文本区的表单，因此，我们将requestHandlers.js修改为如下形式： function start(response) { console.log(&quot;Request handler &apos;start&apos; was called.&quot;); var body = &apos;&lt;html&gt;&apos;+ &apos;&lt;head&gt;&apos;+ &apos;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; &apos;+ &apos;charset=UTF-8&quot; /&gt;&apos;+ &apos;&lt;/head&gt;&apos;+ &apos;&lt;body&gt;&apos;+ &apos;&lt;form action=&quot;/upload&quot; method=&quot;post&quot;&gt;&apos;+ &apos;&lt;textarea name=&quot;text&quot; rows=&quot;20&quot; cols=&quot;60&quot;&gt;&lt;/textarea&gt;&apos;+ &apos;&lt;input type=&quot;submit&quot; value=&quot;Submit text&quot; /&gt;&apos;+ &apos;&lt;/form&gt;&apos;+ &apos;&lt;/body&gt;&apos;+ &apos;&lt;/html&gt;&apos;; response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;}); response.write(body); response.end(); } function upload(response) { console.log(&quot;Request handler &apos;upload&apos; was called.&quot;); response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(&quot;Hello Upload&quot;); response.end(); } exports.start = start; exports.upload = upload; 好了，现在我们的应用已经很完善了，都可以获得威比奖（Webby Awards）了，哈哈。（译者注：威比奖是由国际数字艺术与科学学院主办的评选全球最佳网站的奖项，具体参见详细说明）通过在浏览器中访问http://localhost:8888/start就可以看到简单的表单了，要记得重启服务器哦！ 你可能会说：这种直接将视觉元素放在请求处理程序中的方式太丑陋了。说的没错，但是，我并不想在本书中介绍诸如MVC之类的模式，因为这对于你了解JavaScript或者Node.js环境来说没多大关系。 余下的篇幅，我们来探讨一个更有趣的问题： 当用户提交表单时，触发/upload请求处理程序处理POST请求的问题。 现在，我们已经是新手中的专家了，很自然会想到采用异步回调来实现非阻塞地处理POST请求的数据。 这里采用非阻塞方式处理是明智的，因为POST请求一般都比较“重” —— 用户可能会输入大量的内容。用阻塞的方式处理大数据量的请求必然会导致用户操作的阻塞。 为了使整个过程非阻塞，Node.js会将POST数据拆分成很多小的数据块，然后通过触发特定的事件，将这些小数据块传递给回调函数。这里的特定的事件有data事件（表示新的小数据块到达了）以及end事件（表示所有的数据都已经接收完毕）。 我们需要告诉Node.js当这些事件触发的时候，回调哪些函数。怎么告诉呢？ 我们通过在request对象上注册监听器（listener） 来实现。这里的request对象是每次接收到HTTP请求时候，都会把该对象传递给onRequest回调函数。 如下所示： request.addListener(&quot;data&quot;, function(chunk) { // called when a new chunk of data was received }); request.addListener(&quot;end&quot;, function() { // called when all chunks of data have been received }); 问题来了，这部分逻辑写在哪里呢？ 我们现在只是在服务器中获取到了request对象 —— 我们并没有像之前response对象那样，把 request 对象传递给请求路由和请求处理程序。 在我看来，获取所有来自请求的数据，然后将这些数据给应用层处理，应该是HTTP服务器要做的事情。因此，我建议，我们直接在服务器中处理POST数据，然后将最终的数据传递给请求路由和请求处理器，让他们来进行进一步的处理。 因此，实现思路就是： 将data和end事件的回调函数直接放在服务器中，在data事件回调中收集所有的POST数据，当接收到所有数据，触发end事件后，其回调函数调用请求路由，并将数据传递给它，然后，请求路由再将该数据传递给请求处理程序。 还等什么，马上来实现。先从server.js开始： var http = require(&quot;http&quot;); var url = require(&quot;url&quot;); function start(route, handle) { function onRequest(request, response) { var postData = &quot;&quot;; var pathname = url.parse(request.url).pathname; console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;); request.setEncoding(&quot;utf8&quot;); request.addListener(&quot;data&quot;, function(postDataChunk) { postData += postDataChunk; console.log(&quot;Received POST data chunk &apos;&quot;+ postDataChunk + &quot;&apos;.&quot;); }); request.addListener(&quot;end&quot;, function() { route(handle, pathname, response, postData); }); } http.createServer(onRequest).listen(8888); console.log(&quot;Server has started.&quot;); } exports.start = start; 上述代码做了三件事情： 首先，我们设置了接收数据的编码格式为UTF-8，然后注册了“data”事件的监听器，用于收集每次接收到的新数据块，并将其赋值给postData 变量，最后，我们将请求路由的调用移到end事件处理程序中，以确保它只会当所有数据接收完毕后才触发，并且只触发一次。我们同时还把POST数据传递给请求路由，因为这些数据，请求处理程序会用到。 上述代码在每个数据块到达的时候输出了日志，这对于最终生产环境来说，是很不好的（数据量可能会很大，还记得吧？），但是，在开发阶段是很有用的，有助于让我们看到发生了什么。 我建议可以尝试下，尝试着去输入一小段文本，以及大段内容，当大段内容的时候，就会发现data事件会触发多次。 再来点酷的。我们接下来在/upload页面，展示用户输入的内容。要实现该功能，我们需要将postData传递给请求处理程序，修改router.js为如下形式： function route(handle, pathname, response, postData) { console.log(&quot;About to route a request for &quot; + pathname); if (typeof handle[pathname] === &apos;function&apos;) { handle[pathname](response, postData); } else { console.log(&quot;No request handler found for &quot; + pathname); response.writeHead(404, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(&quot;404 Not found&quot;); response.end(); } } exports.route = route; 然后，在requestHandlers.js中，我们将数据包含在对upload请求的响应中： function start(response, postData) { console.log(&quot;Request handler &apos;start&apos; was called.&quot;); var body = &apos;&lt;html&gt;&apos;+ &apos;&lt;head&gt;&apos;+ &apos;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; &apos;+ &apos;charset=UTF-8&quot; /&gt;&apos;+ &apos;&lt;/head&gt;&apos;+ &apos;&lt;body&gt;&apos;+ &apos;&lt;form action=&quot;/upload&quot; method=&quot;post&quot;&gt;&apos;+ &apos;&lt;textarea name=&quot;text&quot; rows=&quot;20&quot; cols=&quot;60&quot;&gt;&lt;/textarea&gt;&apos;+ &apos;&lt;input type=&quot;submit&quot; value=&quot;Submit text&quot; /&gt;&apos;+ &apos;&lt;/form&gt;&apos;+ &apos;&lt;/body&gt;&apos;+ &apos;&lt;/html&gt;&apos;; response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;}); response.write(body); response.end(); } function upload(response, postData) { console.log(&quot;Request handler &apos;upload&apos; was called.&quot;); response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(&quot;You&apos;ve sent: &quot; + postData); response.end(); } exports.start = start; exports.upload = upload; 好了，我们现在可以接收POST数据并在请求处理程序中处理该数据了。 我们最后要做的是： 当前我们是把请求的整个消息体传递给了请求路由和请求处理程序。我们应该只把POST数据中，我们感兴趣的部分传递给请求路由和请求处理程序。在我们这个例子中，我们感兴趣的其实只是text字段。 我们可以使用此前介绍过的querystring模块来实现： var querystring = require(&quot;querystring&quot;); function start(response, postData) { console.log(&quot;Request handler &apos;start&apos; was called.&quot;); var body = &apos;&lt;html&gt;&apos;+ &apos;&lt;head&gt;&apos;+ &apos;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; &apos;+ &apos;charset=UTF-8&quot; /&gt;&apos;+ &apos;&lt;/head&gt;&apos;+ &apos;&lt;body&gt;&apos;+ &apos;&lt;form action=&quot;/upload&quot; method=&quot;post&quot;&gt;&apos;+ &apos;&lt;textarea name=&quot;text&quot; rows=&quot;20&quot; cols=&quot;60&quot;&gt;&lt;/textarea&gt;&apos;+ &apos;&lt;input type=&quot;submit&quot; value=&quot;Submit text&quot; /&gt;&apos;+ &apos;&lt;/form&gt;&apos;+ &apos;&lt;/body&gt;&apos;+ &apos;&lt;/html&gt;&apos;; response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;}); response.write(body); response.end(); } function upload(response, postData) { console.log(&quot;Request handler &apos;upload&apos; was called.&quot;); response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(&quot;You&apos;ve sent the text: &quot;+ querystring.parse(postData).text); response.end(); } exports.start = start; exports.upload = upload; 好了，以上就是关于处理POST数据的全部内容。 处理文件上传 最后，我们来实现我们最终的用例：允许用户上传图片，并将该图片在浏览器中显示出来。 回到90年代，这个用例完全可以满足用于IPO的商业模型了，如今，我们通过它能学到这样两件事情： 如何安装外部Node.js模块，以及如何将它们应用到我们的应用中。 这里我们要用到的外部模块是Felix Geisendörfer开发的node-formidable模块。它对解析上传的文件数据做了很好的抽象。 其实说白了，处理文件上传“就是”处理POST数据 —— 但是，麻烦的是在具体的处理细节，所以，这里采用现成的方案更合适点。 使用该模块，首先需要安装该模块。Node.js有它自己的包管理器，叫NPM。它可以让安装Node.js的外部模块变得非常方便。通过如下一条命令就可以完成该模块的安装： npm install formidable 如果终端输出如下内容： npm info build Success: formidable@1.0.9 npm ok 就说明模块已经安装成功了。 现在我们就可以用formidable模块了——使用外部模块与内部模块类似，用require语句将其引入即可： var formidable = require(&quot;formidable&quot;); 这里该模块做的就是将通过HTTP POST请求提交的表单，在Node.js中可以被解析。我们要做的就是创建一个新的IncomingForm，它是对提交表单的抽象表示，之后，就可以用它解析request对象，获取表单中需要的数据字段。 node-formidable官方的例子展示了这两部分是如何融合在一起工作的： var formidable = require(&apos;formidable&apos;), http = require(&apos;http&apos;), util = require(&apos;util&apos;); http.createServer(function(req, res) { if (req.url == &apos;/upload&apos; &amp;&amp; req.method.toLowerCase() == &apos;post&apos;) { // parse a file upload var form = new formidable.IncomingForm(); form.parse(req, function(err, fields, files) { res.writeHead(200, {&apos;content-type&apos;: &apos;text/plain&apos;}); res.write(&apos;received upload:\n\n&apos;); res.end(util.inspect({fields: fields, files: files})); }); return; } // show a file upload form res.writeHead(200, {&apos;content-type&apos;: &apos;text/html&apos;}); res.end( &apos;&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; &apos;+ &apos;method=&quot;post&quot;&gt;&apos;+ &apos;&lt;input type=&quot;text&quot; name=&quot;title&quot;&gt;&lt;br&gt;&apos;+ &apos;&lt;input type=&quot;file&quot; name=&quot;upload&quot; multiple=&quot;multiple&quot;&gt;&lt;br&gt;&apos;+ &apos;&lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt;&apos;+ &apos;&lt;/form&gt;&apos; ); }).listen(8888); 如果我们将上述代码，保存到一个文件中，并通过node来执行，就可以进行简单的表单提交了，包括文件上传。然后，可以看到通过调用form.parse传递给回调函数的files对象的内容，如下所示： received upload: { fields: { title: &apos;Hello World&apos; }, files: { upload: { size: 1558, path: &apos;/tmp/1c747974a27a6292743669e91f29350b&apos;, name: &apos;us-flag.png&apos;, type: &apos;image/png&apos;, lastModifiedDate: Tue, 21 Jun 2011 07:02:41 GMT, _writeStream: [Object], length: [Getter], filename: [Getter], mime: [Getter] } } } 为了实现我们的功能，我们需要将上述代码应用到我们的应用中，另外，我们还要考虑如何将上传文件的内容（保存在/tmp目录中）显示到浏览器中。 我们先来解决后面那个问题： 对于保存在本地硬盘中的文件，如何才能在浏览器中看到呢？ 显然，我们需要将该文件读取到我们的服务器中，使用一个叫fs的模块。 我们来添加/showURL的请求处理程序，该处理程序直接硬编码将文件/tmp/test.png内容展示到浏览器中。当然了，首先需要将该图片保存到这个位置才行。 将requestHandlers.js修改为如下形式： var querystring = require(&quot;querystring&quot;), fs = require(&quot;fs&quot;); function start(response, postData) { console.log(&quot;Request handler &apos;start&apos; was called.&quot;); var body = &apos;&lt;html&gt;&apos;+ &apos;&lt;head&gt;&apos;+ &apos;&lt;meta http-equiv=&quot;Content-Type&quot; &apos;+ &apos;content=&quot;text/html; charset=UTF-8&quot; /&gt;&apos;+ &apos;&lt;/head&gt;&apos;+ &apos;&lt;body&gt;&apos;+ &apos;&lt;form action=&quot;/upload&quot; method=&quot;post&quot;&gt;&apos;+ &apos;&lt;textarea name=&quot;text&quot; rows=&quot;20&quot; cols=&quot;60&quot;&gt;&lt;/textarea&gt;&apos;+ &apos;&lt;input type=&quot;submit&quot; value=&quot;Submit text&quot; /&gt;&apos;+ &apos;&lt;/form&gt;&apos;+ &apos;&lt;/body&gt;&apos;+ &apos;&lt;/html&gt;&apos;; response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;}); response.write(body); response.end(); } function upload(response, postData) { console.log(&quot;Request handler &apos;upload&apos; was called.&quot;); response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(&quot;You&apos;ve sent the text: &quot;+ querystring.parse(postData).text); response.end(); } function show(response, postData) { console.log(&quot;Request handler &apos;show&apos; was called.&quot;); fs.readFile(&quot;/tmp/test.png&quot;, &quot;binary&quot;, function(error, file) { if(error) { response.writeHead(500, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(error + &quot;\n&quot;); response.end(); } else { response.writeHead(200, {&quot;Content-Type&quot;: &quot;image/png&quot;}); response.write(file, &quot;binary&quot;); response.end(); } }); } exports.start = start; exports.upload = upload; exports.show = show; 我们还需要将这新的请求处理程序，添加到index.js中的路由映射表中： var server = require(&quot;./server&quot;); var router = require(&quot;./router&quot;); var requestHandlers = require(&quot;./requestHandlers&quot;); var handle = {} handle[&quot;/&quot;] = requestHandlers.start; handle[&quot;/start&quot;] = requestHandlers.start; handle[&quot;/upload&quot;] = requestHandlers.upload; handle[&quot;/show&quot;] = requestHandlers.show; server.start(router.route, handle); 重启服务器之后，通过访问http://localhost:8888/show，就可以看到保存在/tmp/test.png的图片了。 好，最后我们要的就是： 在/start表单中添加一个文件上传元素 将node-formidable整合到我们的upload请求处理程序中，用于将上传的图片保存到/tmp/test.png 将上传的图片内嵌到/uploadURL输出的HTML中 第一项很简单。只需要在HTML表单中，添加一个multipart/form-data的编码类型，移除此前的文本区，添加一个文件上传组件，并将提交按钮的文案改为“Upload file”即可。 如下requestHandler.js所示： var querystring = require(&quot;querystring&quot;), fs = require(&quot;fs&quot;); function start(response, postData) { console.log(&quot;Request handler &apos;start&apos; was called.&quot;); var body = &apos;&lt;html&gt;&apos;+ &apos;&lt;head&gt;&apos;+ &apos;&lt;meta http-equiv=&quot;Content-Type&quot; &apos;+ &apos;content=&quot;text/html; charset=UTF-8&quot; /&gt;&apos;+ &apos;&lt;/head&gt;&apos;+ &apos;&lt;body&gt;&apos;+ &apos;&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; &apos;+ &apos;method=&quot;post&quot;&gt;&apos;+ &apos;&lt;input type=&quot;file&quot; name=&quot;upload&quot;&gt;&apos;+ &apos;&lt;input type=&quot;submit&quot; value=&quot;Upload file&quot; /&gt;&apos;+ &apos;&lt;/form&gt;&apos;+ &apos;&lt;/body&gt;&apos;+ &apos;&lt;/html&gt;&apos;; response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;}); response.write(body); response.end(); } function upload(response, postData) { console.log(&quot;Request handler &apos;upload&apos; was called.&quot;); response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(&quot;You&apos;ve sent the text: &quot;+ querystring.parse(postData).text); response.end(); } function show(response, postData) { console.log(&quot;Request handler &apos;show&apos; was called.&quot;); fs.readFile(&quot;/tmp/test.png&quot;, &quot;binary&quot;, function(error, file) { if(error) { response.writeHead(500, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(error + &quot;\n&quot;); response.end(); } else { response.writeHead(200, {&quot;Content-Type&quot;: &quot;image/png&quot;}); response.write(file, &quot;binary&quot;); response.end(); } }); } exports.start = start; exports.upload = upload; exports.show = show; 很好。下一步相对比较复杂。这里有这样一个问题： 我们需要在upload处理程序中对上传的文件进行处理，这样的话，我们就需要将request对象传递给node-formidable的form.parse函数。 但是，我们有的只是response对象和postData数组。看样子，我们只能不得不将request对象从服务器开始一路通过请求路由，再传递给请求处理程序。 或许还有更好的方案，但是，不管怎么说，目前这样做可以满足我们的需求。 到这里，我们可以将postData从服务器以及请求处理程序中移除了 —— 一方面，对于我们处理文件上传来说已经不需要了，另外一方面，它甚至可能会引发这样一个问题： 我们已经“消耗”了request对象中的数据，这意味着，对于form.parse来说，当它想要获取数据的时候就什么也获取不到了。（因为Node.js不会对数据做缓存） 我们从server.js开始 —— 移除对postData的处理以及request.setEncoding （这部分node-formidable自身会处理），转而采用将request对象传递给请求路由的方式： var http = require(&quot;http&quot;); var url = require(&quot;url&quot;); function start(route, handle) { function onRequest(request, response) { var pathname = url.parse(request.url).pathname; console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;); route(handle, pathname, response, request); } http.createServer(onRequest).listen(8888); console.log(&quot;Server has started.&quot;); } exports.start = start; 接下来是 router.js —— 我们不再需要传递postData了，这次要传递request对象： function route(handle, pathname, response, request) { console.log(&quot;About to route a request for &quot; + pathname); if (typeof handle[pathname] === &apos;function&apos;) { handle[pathname](response, request); } else { console.log(&quot;No request handler found for &quot; + pathname); response.writeHead(404, {&quot;Content-Type&quot;: &quot;text/html&quot;}); response.write(&quot;404 Not found&quot;); response.end(); } } exports.route = route; 现在，request对象就可以在我们的upload请求处理程序中使用了。node-formidable会处理将上传的文件保存到本地/tmp目录中，而我们需要做的是确保该文件保存成/tmp/test.png。 没错，我们保持简单，并假设只允许上传PNG图片。 这里采用fs.renameSync(path1,path2)来实现。要注意的是，正如其名，该方法是同步执行的， 也就是说，如果该重命名的操作很耗时的话会阻塞。 这块我们先不考虑。 接下来，我们把处理文件上传以及重命名的操作放到一起，如下requestHandlers.js所示： var querystring = require(&quot;querystring&quot;), fs = require(&quot;fs&quot;), formidable = require(&quot;formidable&quot;); function start(response) { console.log(&quot;Request handler &apos;start&apos; was called.&quot;); var body = &apos;&lt;html&gt;&apos;+ &apos;&lt;head&gt;&apos;+ &apos;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; &apos;+ &apos;charset=UTF-8&quot; /&gt;&apos;+ &apos;&lt;/head&gt;&apos;+ &apos;&lt;body&gt;&apos;+ &apos;&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; &apos;+ &apos;method=&quot;post&quot;&gt;&apos;+ &apos;&lt;input type=&quot;file&quot; name=&quot;upload&quot; multiple=&quot;multiple&quot;&gt;&apos;+ &apos;&lt;input type=&quot;submit&quot; value=&quot;Upload file&quot; /&gt;&apos;+ &apos;&lt;/form&gt;&apos;+ &apos;&lt;/body&gt;&apos;+ &apos;&lt;/html&gt;&apos;; response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;}); response.write(body); response.end(); } function upload(response, request) { console.log(&quot;Request handler &apos;upload&apos; was called.&quot;); var form = new formidable.IncomingForm(); console.log(&quot;about to parse&quot;); form.parse(request, function(error, fields, files) { console.log(&quot;parsing done&quot;); fs.renameSync(files.upload.path, &quot;/tmp/test.png&quot;); response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;}); response.write(&quot;received image:&lt;br/&gt;&quot;); response.write(&quot;&lt;img src=&apos;/show&apos; /&gt;&quot;); response.end(); }); } function show(response) { console.log(&quot;Request handler &apos;show&apos; was called.&quot;); fs.readFile(&quot;/tmp/test.png&quot;, &quot;binary&quot;, function(error, file) { if(error) { response.writeHead(500, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.write(error + &quot;\n&quot;); response.end(); } else { response.writeHead(200, {&quot;Content-Type&quot;: &quot;image/png&quot;}); response.write(file, &quot;binary&quot;); response.end(); } }); } exports.start = start; exports.upload = upload; exports.show = show; 好了，重启服务器，我们应用所有的功能就可以用了。选择一张本地图片，将其上传到服务器，然后浏览器就会显示该图片。 总结与展望 恭喜，我们的任务已经完成了！我们开发完了一个Node.js的web应用，应用虽小，但却“五脏俱全”。 期间，我们介绍了很多技术点：服务端JavaScript、函数式编程、阻塞与非阻塞、回调、事件、内部和外部模块等等。 当然了，还有许多本书没有介绍到的： 如何操作数据库、如何进行单元测试、如何开发Node.js的外部模块以及一些简单的诸如如何获取GET请求之类的方法。 但本书毕竟只是一本给初学者的教程 —— 不可能覆盖到所有的内容。 幸运的是，Node.js社区非常活跃（作个不恰当的比喻就是犹如一群有多动症小孩子在一起，能不活跃吗？）， 这意味着，有许多关于Node.js的资源，有什么问题都可以向社区寻求解答。 其中Node.js社区的wiki以及 NodeCloud就是最好的资源。 引用地址：http://www.nodebeginner.org/index-zh-cn.html?utm_source=ourjs.com]]></content>
      <categories>
        <category>lessons</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几款LINUX下的CHM查看器]]></title>
    <url>%2F2015%2F11%2F28%2F2015-2015-11-28-linux-chm-viewer%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 本文旨在介绍linux下的常见chm阅读软件及其安装，并针对一些问题给出解决方法。 一、CHMSEE这个比较常见了，呵呵。 安装: sudo apt-get install chmsee 之后在应用程序附件中就可以看到了。 ####问题1： 启动不了或者出现 chmsee: error while loading shared libraries: libxul.so: cannot open shared object file: No such file or directory 的错误就作如下处理： cd /usr/lib sudo ln -s xulrunner-1.9/libxul.so libxul.so sudo ln -s xulrunner-1.9/libxpcom.so libxpcom.so sudo ln -s xulrunner-1.9/libsqlite3.so libsqlite3.so sudo ln -s xulrunner-1.9/libmozjs.so libmozjs.so 之后可以正常打开了。 二、Kchmiewer这个是kde下出色一个chm阅读器，相比较于chmsee出现中文乱马的情况而言，这个可以说是完美了。安装： sudo apt-get install kchmviewer 在ubuntu8.04下，依然在应用程序，附件中出现。 ###三、xchm 安装： sudo apt-get install xchm 四、chmview它是个非常强大的chm阅读器。不过其原理略微有点复杂。我们知道chm实际上是被编译过的html，对了，chmview就是建立了一个简单的http服务器，借助于浏览器来阅读chm，这个就是其基本服务原理。不过有时候也会有点莫名其妙的错误。 五、GNOCHM这是一个比较完美的chm阅读器了，可以说是完美支持中文的。 sudo apt-get install gnochm 六、okularsudo apt-get install gnochm sudo apt-get install okular-extra-backends 七、fbreadersudo apt-get install fbreader 引用地址：http://blog.csdn.net/aking21alinjuju/article/details/4436440]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>reader</tag>
        <tag>chm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debian安装Openjdk7]]></title>
    <url>%2F2015%2F11%2F27%2F2015-2015-11-27-debian-openjdk%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 在命令行中，键入： apt-get install openjdk-7-jre 需要注意的是，openjdk-7-jre包只包含Java运行时环境（Java Runtime Environment）。如果是要开发Java应用程序，则需要安装openjdk-7-jdk包。命令如下： apt-get install openjdk-7-jdk]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>debian</tag>
        <tag>openjdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下安装Cygwin及包管理器apt-cyg]]></title>
    <url>%2F2015%2F11%2F07%2F2015-2015-11-07-windows-cygwin-apt%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 依赖 wget tar gawk bzip2 执行 wget http://apt-cyg.googlecode.com/svn/trunk/apt-cyg -P /bin chmod.exe +x /bin/apt-cyg 更换镜像 apt-cyg -m http://mirrors.163.com/cygwin/ 更新源 apt-cyg update 安装 apt-cyg install ping -u -u表示每次不用更新源 如果每次安装都报错的话，参考 http://www.07net01.com/2015/08/891311.html -# install apt-cyg lynx -source rawgit.com/transcode-open/apt-cyg/master/apt-cyg &gt; apt-cyg -#install install apt-cyg /bin -#link source apt-cyg -m http://mirrors.163.com/cygwin/ -#update apt-cyg update -#Example use of apt-cyg: apt-cyg install nano 引用地址：http://my.oschina.net/looly/blog/214857]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Unit php5-fpm.service is masked]]></title>
    <url>%2F2015%2F10%2F28%2F2015-2015-10-28-php-fpm-is-masked%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 有时安装 nginx php 等时，会遇到些问题 Unit php5-fpm.service is masked。。。 systemctl unmask php5-fpm 其它同理]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Headers and client library minor version mismatch. Headers:50544 Library:506]]></title>
    <url>%2F2015%2F10%2F14%2F2015-2015-10-14-mysql-error-50544%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 Headers and client library minor version mismatch. Headers:50544 Library:506 sudo apt-get remove php5-mysql sudo apt-get install php5-mysqlnd]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[转]debian 编译安装redis]]></title>
    <url>%2F2015%2F10%2F04%2F2015-2015-10-04-debian-install-redis-mf%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 Debian系统自带的Redis版本为2.4，Ubuntu自带的版本为2.8，都不是最新的3.0.2版本，不得不自己手工编译。流程如下： 安装构建包 sudo apt-get install build-essential 下载源码 到 Redis首页 下载最新版本的源码，当前版本为 3.0.2：http://download.redis.io/releases/redis-3.0.2.tar.gz 编译 万幸，Redis是纯C开发，也没依赖什么特殊的库，解压后直接编译即可。 tar xvf redis-3.0.2.tar.gz cd redis-3.0.2 make make test 安装 一般Linux下的软件在编译完之后都是用make install，但通常所谓的安装只是单纯的拷贝文件到PATH目录下，并没有把redis-server注册为系统服务。还好，我们用Debian/Ubuntu就是有特权！Redis提供了一个工具，在安装完毕之后可帮忙注册系统服务。 sudo make install cd utils sudo ./install_server.sh 根据提示填写默认端口、日志路径、配置文件路径等，可惜没有让我们填写系统服务的名称，默认名称为 redis_6379，我还是喜欢服务名叫 redis-server，因此需要执行如下代码： sudo mv /etc/init.d/redis{_6379,-server} 这样通过 sudo service redis-server restart 就能管理Redis服务器了。 测试 $ redis-cli PING PONG 引用地址：http://www.w2bc.com/Article/44498]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>debian</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debian 安装并启动redis]]></title>
    <url>%2F2015%2F10%2F04%2F2015-2015-10-04-debian-install-redis%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 安装 $ apt-get install redis-server 最后一步启动的时候可能会出错，先不用理他，执行以下语句 $ cp /etc/redis/redis.comf /etc/redis/redis.conf.default 启动并加载配置文件 $ redis-server /etc/redis/redis.conf 测试 $ redis-cli redis&gt; set foo bar OK redis&gt; get foo &quot;bar&quot; 完工]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>debian</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debian 安装phpredis 扩展]]></title>
    <url>%2F2015%2F10%2F04%2F2015-2015-10-04-debian-install-phpredis%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 1 安装redis server sudo apt-get install redis-server 2 没有安装phpize ，需要安装php5-dev sudo apt-get install php5-dev 3 安装phpredis https://github.com/nicolasff/phpredis 下载并解压到。我解压到/home/len/soft/nicolasff-phpredis-1d6133d/ cd 到该目录，依次执行 phpize5 ./configure make make install(没权限时加上 sudo) 4 配置php.ini 我安装的是apache 创建 /etc/php5/apache2/conf.d/redis.ini 添加 extension=redis.so 5 重启apache sudo apache2ctl restart 查看phpinfo().确认是否安装成功 以下为自己写的 如果步骤1报错，可以点击此方法安装 redis-server 引用地址：http://blog.csdn.net/liangpz521/article/details/7822811]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>debian</tag>
        <tag>php</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP处理JSON字符串key缺少双引号的解决方法]]></title>
    <url>%2F2015%2F09%2F28%2F2015-2015-09-28-php-json-key%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 这篇文章主要介绍了PHP处理JSON字符串key缺少双引号的解决方法,是非常常见的一类错误处理情况,需要的朋友可以参考下 本文实例讲述了PHP处理JSON字符串key缺少引号的解决方法，分享给大家供大家参考之用。具体方法如下： 通常来说，JSON字符串是key:value形式的字符串，正常key是由双引号括起来的。 例如： &lt;?php $data = array(&apos;name&apos;=&gt;&apos;fdipzone&apos;); echo json_encode($data); // {&quot;name&quot;:&quot;fdipzone&quot;} print_r(json_decode(json_encode($data), true)); //Array ( [name] =&gt; fdipzone ) 但如果json字符串的key缺少双引括起来，则json_decode会失败。 &lt;?php $str = &apos;{&quot;name&quot;:&quot;fdipzone&quot;}&apos;; var_dump(json_decode($str, true)); // array(1) { [&quot;name&quot;]=&gt; string(8) &quot;fdipzone&quot; } $str1 = &apos;{name:&quot;fdipzone&quot;}&apos;; var_dump(json_decode($str1, true)); // NULL ?&gt; 解决方法：判断是否存在缺少双引括起来的key，如缺少则先用正则替换为”key”，再进行json_decode操作。 &lt;?php /** 兼容key没有双引括起来的JSON字符串解析 * @param String $str JSON字符串 * @param boolean $mod true:Array,false:Object * @return Array/Object */ function ext_json_decode($str, $mode=false){ if(preg_match(&apos;/\w:/&apos;, $str)){ $str = preg_replace(&apos;/(\w+):/is&apos;, &apos;&quot;$1&quot;:&apos;, $str); } return json_decode($str, $mode); } $str = &apos;{&quot;name&quot;:&quot;fdipzone&quot;}&apos;; var_dump(ext_json_decode($str, true)); // array(1) { [&quot;name&quot;]=&gt; string(8) &quot;fdipzone&quot; } $str1 = &apos;{name:&quot;fdipzone&quot;}&apos;; var_dump(ext_json_decode($str1, true)); // array(1) { [&quot;name&quot;]=&gt; string(8) &quot;fdipzone&quot; } ?&gt; 希望本文所述对大家PHP程序设计的学习有所帮助。 引用地址：http://www.jb51.net/article/55208.htm]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]在命令行下运行PHP脚本[带参数]的方法]]></title>
    <url>%2F2015%2F09%2F27%2F2015-2015-09-27-php-console-params%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 这里介绍的是在命令行执行php脚本的代码，其实主要用到的是php.exe,所以注意设置环境变量。 创建一个简单的文本文件，其中包含有以下PHP代码，并把它保存为hello.php： 复制代码代码如下: &lt;?php echo &quot;Hello from the CLI&quot;; ?&gt; 现在，试着在命令行提示符下运行这个程序，方法是调用CLI可执行文件并提供脚本的文件名： #php phphello.php //输出Hello from the CLI 使用标准的输入和输出你可以在自己的PHP脚本里使用这三个常量，以接受用户的输入，或者显示处理和计算的结果。要更好地理解这一点，可以看看下面的脚本（列表A）： 列表A 复制代码代码如下: &lt;?php // ask for input fwrite(STDOUT, &quot;Enter your name: &quot;); // get input $name = trim(fgets(STDIN)); // write input back fwrite(STDOUT, &quot;Hello, $name!&quot;); ?&gt; Look what happens when you run it: shell&gt; php hello.php Enter your name: Joe // Hello, Joe! 在这个脚本里，fwrite()函数首先会向标准的输出设备写一条消息，询问用户的姓名。然后它会把从标准输入设备获得的用户输入信息读 取到一个PHP变量里，并它把合并成为一个字符串。然后就用fwrite()把这个字符串打印输出到标准的输出设备上。 —————–使用命令行自变量 在命令行里输入程序参数来更改其运行方式是很常见的做法。你也可以对CLI程序这样做。PHP CLI带有两个特殊的变量，专门用来达到这个 目的：一个是$argv变量，它通过命令行把传递给PHP脚本的参数保存为单独的数组元素；另一个是$argc变量，它用来保存$argv数组里元素的 个数。 用PHP脚本编写一段读取$argv并处理它所含参数的代码是很简单的。试试列表B里的示例脚本，看看它是如何工作的： 列表B 复制代码代码如下: &lt;?php print_r($argv); ?&gt; Run this script by passing it some arbitrary values, and check the output: shell&gt; php phptest.php chocolate 276 &quot;killer tie, dude!&quot; Array ( [0] =&gt; test.php [1] =&gt; chocolate [2] =&gt; 276 [3] =&gt; killer tie, dude! ) 正如你可以从输出的结果看到的，传递给test.php的值会自动地作为数组元素出现在$argv里。要注意的是，$argvis的第一个自变量总是 脚本自己的名称。 下面是一个更加复杂的例子（列表C）： 列表C 代码 复制代码代码如下: &lt;?php // check for all required arguments // first argument is always name of script! if ($argc != 4) { die(&quot;Usage: book.php &lt;check-in-date&gt; &lt;num-nights&gt; &lt;room-type&gt; &quot;); } // remove first argument array_shift($argv); // get and use remaining arguments $checkin = $argv[0]; $nights = $argv[1]; $type = $argv[2]; echo &quot;You have requested a $type room for $nights nights, checking in on $checkin. Thank you for your order! &quot;; ?&gt; 下面是其用法的示例： shell&gt; php phpbook.php 21/05/2005 7 single You have requested a single room for 7 nights, checking in on 21/05/2005. Thank you for your order! 在这里，脚本首先会检查$argc，以确保自变量的数量符合要求。它然后会从$argv里提取出每一个自变量，把它们打印输出到标准的输出 引用地址：http://www.jb51.net/article/21879.htm]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>cli</tag>
        <tag>params</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debian区分版本]]></title>
    <url>%2F2015%2F09%2F22%2F2015-2015-09-22-debian-version-diff%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 1、输入命令 lsb_release -a 2、输入命令 cat /etc/issue #6-squeeze #7-wheezy #8-jessie]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>debian</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debian 7 apt-get一键安装配置搭建最新LNMP]]></title>
    <url>%2F2015%2F09%2F18%2F2015-2015-09-18-debian-install-lnmp%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 1.我们首先要导入dotdeb源： 打开 /etc/apt/sources.list。 向其中添加如下四行： deb http://packages.dotdeb.org wheezy all deb-src http://packages.dotdeb.org wheezy all deb http://packages.dotdeb.org wheezy-php56 all deb-src http://packages.dotdeb.org wheezy-php56 all 下载并导入GnuPG key： wget http://www.dotdeb.org/dotdeb.gpg cat dotdeb.gpg | apt-key add - 2.更新debian安装源： apt-get update 3.使用命令一键安装lnmp： apt-get install nginx mysql-server php5-fpm php5-curl php5-gd php5-intl php-pear php5-imagick php5-imap php5-mcrypt php5-common php5-mysql php5-pspell php5-recode php5-snmp php5-sqlite php5-tidy php5-xmlrpc php5-xsl php5-memcached memcached 4.配置环境： 执行下面命令： vi /etc/nginx/sites-available/default 按照下面来修改： ......location ~ \.php$ { fastcgi_split_path_info ^(.+\.php)(/.+)$; # # NOTE: You should have &quot;cgi.fix_pathinfo = 0;&quot; in php.ini ## # With php5-cgi alone: # fastcgi_pass 127.0.0.1:9000; # # With php5-fpm: fastcgi_pass unix:/var/run/php5-fpm.sock; fastcgi_index index.php;include fastcgi_params; }..... 修改保存之后重启Nginx： service nginx restart 接下来我们下载一个探针，查看php的详细信息： cd /usr/share/nginx/html/ wget http://www.yahei.net/tz/tz.zip unzip tz.zip 保存之后访问网站网址 , 如果出现雅黑探针页面，则大功告成。 5.如何新建站点： 和一般的lnmp一键包不同，采用这个方法所安装的 LNMP 需要手动添加站点配置文件。 进入配置文件目录，新建一个站点配置文件，比如 vi abcd.com.conf。 cd /etc/nginx/conf.d 按照下面添加配置文件： server { listen 80; #ipv6#listen [::]:80 default_server; root /usr/share/nginx/html/abcd.com; #默认首页文件名 index index.php index.html index.htm; #绑定域名 server_name abcd.com; #伪静态规则 include wordpress.conf; location \ { try_files $uri $uri/ /index.html; } #定义错误页面 #error_page 404 /404.html; location ~ \.php$ { fastcgi_split_path_info ^(.+\.php)(/.+)$; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi_params; } #PHP } 保存之后重启Nginx，添加及绑定网站即完成。 最后，附上WordPress的Nginx伪静态规则： location / { if (-f $request_filename/index.html){ rewrite (.*) $1/index.html break; } if (-f $request_filename/index.php){ rewrite (.*) $1/index.php; } if (!-f $request_filename){ rewrite (.*) /index.php; } } 错误：1、步骤2的问题]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>debian</tag>
        <tag>lnmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php中的json转码问题以及保存在mysql中出现的问题]]></title>
    <url>%2F2015%2F09%2F09%2F2015-2015-09-09-php-json-mysql%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 出现问题及解决方法 json_encode(‘中文’);会生成 “\u4e2d\u6587”要转回来就用json_decode(‘“\u4e2d\u6587”‘)就行了，但这不算一个问题。 当你需要将你的某项数据通过json_encode()再存入数据库的话，就会出问题。数据库中显示“”u4e2du6587””，少了斜杠就转不回“中文”了。这种情况的就可以用以下方法解决 a、用 addslashes()处理后再存入数据库 $str = json_encode(&apos;中文&apos;); $str = addslashes($str); echo $str; //结果为{&quot;str&quot;:&quot;\u4e2d\u6587&quot;} b、用 json_encode(‘中文’,JSON_UNESCAPED_UNICODE)处理的中文后，不会转为”\xxxx\xxxx”这个格式，直接转为’”中文”‘。本功能在php5.4以上才能使用 $str = json_encode(&apos;中文&apos;,JSON_UNESCAPED_UNICODE); //结果为&quot;中文&quot; $str = json_encode(array(&apos;str&apos;=&gt;&apos;中文&apos;),JSON_UNESCAPED_UNICODE); echo $str; //结果为{&quot;str&quot;:&quot;中文&quot;} c、对于5.4以下的版本，可以对json_encode()后的字符串用正则替换 $str = &apos;中文&apos;; $str = json_encode($str); $str = preg_replace(&quot;#\\\u([0-9a-f]{4})#ie&quot;, &quot;iconv(&apos;UCS-2BE&apos;, &apos;UTF-8&apos;, pack(&apos;H4&apos;, &apos;\\1&apos;))&quot;, $name); //结果为&quot;中文&quot; $arr= array(&apos;str&apos;=&gt;&apos;中文&apos;); $str = json_encode($arr); $str = preg_replace(&quot;#\\\u([0-9a-f]{4})#ie&quot;, &quot;iconv(&apos;UCS-2BE&apos;, &apos;UTF-8&apos;, pack(&apos;H4&apos;, &apos;\\1&apos;))&quot;, $name); echo $str; //结果为{&quot;str&quot;:&quot;中文&quot;} 有时为了兼容性，可以将b、c方法封装成类 以下为封装代码 class JSON { /** * @brief json数据格式编码,支持中文原文转换 * @param $param max 要编码转换的数据 * @return String json数据格式 */ public static function encode($param) { if(version_compare(phpversion(),&apos;5.4.0&apos;) &gt;= 0) { return json_encode($param,JSON_UNESCAPED_UNICODE); } $result = json_encode($param); //对于中文的转换 return preg_replace(&quot;#\\\u([0-9a-f]{4})#ie&quot;, &quot;iconv(&apos;UCS-2BE&apos;, &apos;UTF-8&apos;, pack(&apos;H4&apos;, &apos;\\1&apos;))&quot;, $result); } /** * @brief 解析json数据格式 * @param $string String 要解析的json串 * @return max php数据格式 */ public static function decode($string) { if(strpos($string,&quot;\t&quot;) !== false) { $string = str_replace(&quot;\t&quot;,&apos;&apos;,$string); } return json_decode($string,true); } } //使用方法 $arr = array(&apos;str&apos;=&gt;&apos;中文&apos;); $str = JSON::encode($arr); echo $str; //结果为{&quot;str&quot;:&quot;中文&quot;}]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>php</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]设置 Debian/Ubuntu 不允许使用 root ssh 登陆]]></title>
    <url>%2F2015%2F09%2F01%2F2015-2015-09-01-debian-without-root-login%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 基本上, root 密碼是什麼我也記不起來(都是亂打的), 不過直接於 ssh 擋掉還是較安全點~(Ubuntu / Debian Linux 預設是允許 root ssh login 的) 設定不允許 root ssh 登入 vim /etc/ssh/sshd_config 找到 PermitRootLogin yes 改成 PermitRootLogin no /etc/init.d/ssh restart 即可. 修改 ssh Port 若有要改跑其它 Port, 一樣於 sshd_config 找到 Port, 將 22 改成想要的 Port number 即可. 限定特定帳號登入 若只允許某些帳號登入: vim /etc/pam.d/sshd # account required pam_access.so 拿掉註解 account required pam_access.so vim /etc/security/access.conf # 照範例設定即可. 這是另一種方法, 此方法我沒試過(摘錄自: SSH 的一些安全小技巧): vi /etc/pam.d/sshd # 加入此行 auth required pam_listfile.so item=user sense=allow file=/etc/ssh_users onerr=fail echo user1 &gt;&gt; /etc/ssh_users # user1 就是你要允許的 user 名稱 (一個帳號一行) 以下为自己加上的： debian 有些版本默认不让root账户登陆，比如debian 8 vim /etc/ssh/sshd_config 找到 PermitRootLogin xxxxxdebian 8 里面是 PermitRootLogin without-password改成 PermitRootLogin yes保存后，运行 /etc/init.d/ssh restart 引用地址：http://blog.longwin.com.tw/2008/10/security-debian-ubuntu-linux-deny-root-login-2008/]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>debian</tag>
        <tag>login</tag>
        <tag>root</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 15.04 gVim安装及设置]]></title>
    <url>%2F2015%2F08%2F17%2F2015-2015-08-17-ubuntu-vim-gvim%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 安装gVim: sudo apt-get install vim-gtk Ubuntu15.04已经提供了youcompleteme等插件，可以直接安装： sudo apt-get install vim-youcompleteme vim-syntastic vim-fugitive tagbar要用到ctags: sudo apt-get install exuberant-ctags CtrlSF需要先安装ag: sudo apt-get install silversearcher-ag 安装matchit插件： $ sudo apt-get install vim-addon-manager vim-scripts $ vim-addons install matchit 通过Vundle安装其他插件 下载Vundle： mkdir ~/.vim/bundle git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim 然后编辑~/.vimrc在前面添加如下内容： //这里差一个图image// 然后重新启动gVim并运行： :PluginInstall 完成插件的最后安装 另外有几个插件还需要做必要的设置： &quot; Ctrl+n调用NERDTree map &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt; &quot; F8调用Tagbar nmap &lt;F8&gt; :TagbarToggle&lt;CR&gt; &quot; AirLine set laststatus=2 &quot; CtrlSF nmap &lt;C-F&gt;n &lt;Plug&gt;CtrlSFCwordPath 另外还需要： vim-addons install youcompleteme 引用地址：http://tieba.baidu.com/p/3602033040]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>debian</tag>
        <tag>vim</tag>
        <tag>gvim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shadowsocks常用配置]]></title>
    <url>%2F2015%2F08%2F11%2F2015-2015-08-11-shadowsocks-config%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 shadowsocks以json为配置文件格式，以下是一个样例： /etc/shadowsocks/config.json { &quot;server&quot;:&quot;remote-shadowsocks-server-ip-addr&quot;, &quot;server_port&quot;:443, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;your-passwd&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;:false, &quot;workers&quot;:1 } 提示: 若需同时指定多个服务端ip，可参考”server”:[“1.1.1.1”,”2.2.2.2”], server 服务端监听地址(IPv4或IPv6) server_port 服务端端口，一般为443 local_address 本地监听地址，缺省为127.0.0.1 local_port 本地监听端口，一般为1080 password 用以加密的密匙 timeout 超时时间（秒） method 加密方法，默认的table是一种不安全的加密，此处首推aes-256-cfb fast_open 是否启用TCP-Fast-Open wokers worker数量，如果不理解含义请不要改 客户端在config.json所在目录下运行sslocal即可；若需指定配置文件的位置： # sslocal -c /etc/shadowsocks/config.json 注意: 有用户报告无法成功在运行时加载config.json，或可尝试手动运行： # sslocal -s 服务器地址 -p 服务器端口 -l 本地端端口 -k 密码 -m 加密方法 提示: 当然也有图形化的使用shadowsocks-gui@gitHub,如果不希望自己编译的话，也可以到shadowsocks-gui@sourceforge下载。 服务端提示: 普通用户无需配置服务端； 在服务器上cd到config.json所在目录： 运行ssserver； 如果想在后台一直运行，可改执行：nohup ssserver &gt; log &amp;； 以守护进程形式运行客户端Shadowsocks的systemd服务可在/etc/shadowsocks/里调用不同的conf-file.json（以conf-file为区分标志），例： 在/etc/shadowsocks/中创建了foo.json配置文件，那么执行以下语句就可以调用该配置： # systemctl start shadowsocks@foo 若需开机自启动： # systemctl enable shadowsocks@foo 提示: 可用journalctl -u shadowsocks@foo来查询日志； 以守护进程形式运行服务端以上只是启动了客户端的守护进程，如果架设的是服务器，则需要： # systemctl start shadowsocks-server@foo # systemctl enable shadowsocks-server@foo 提示: 如果使用的服务端端口号小于1024，需要修改usr/lib/systemd/system/shadowsocks-server@.service使得user=root，之后使用systemctl daemon-reload重新载入守护进程配置，即可开启监听。 加密注意: 默认加密方法table速度很快，但很不安全。推荐使用aes-256-cfb或者bf-cfb，照目前的趋势，ChaCha20是占用最小速度最快的一种方式。请不要使用rc4，它不安全。 提示: 安装M2Crypto可略微提升加密速度，对于Python2来说，安装python2-m2crypto即可。 可选的加密方式： aes-256-cfb: 默认加密方式 aes-128-cfb aes-192-cfb aes-256-ofb aes-128-ofb aes-192-ofb aes-128-ctr aes-192-ctr aes-256-ctr aes-128-cfb8 aes-192-cfb8 aes-256-cfb8 aes-128-cfb1 aes-192-cfb1 aes-256-cfb1 bf-cfb camellia-128-cfb camellia-192-cfb camellia-256-cfb cast5-cfb chacha20 idea-cfb rc2-cfb rc4-md5 salsa20 seed-cfb 注意: 官方软件源的shadowsocks不支持全部加密方式，官方软件源Chacha20以及salsa20的支持可以安装libsodium（For salsa20 and chacha20 support） 。若对非主流加密方式有需求，可尝试aur中的shadowsocks-nodejsAUR[broken link: archived in aur-mirror] Chrome/Chromium至此，本地监听端口127.0.0.1:1080已配置完毕。现以Chrome/Chromium为例，示范使用代理服务器的方法。 请安装 Proxy SwitchyOmega插件（SwitchySharp已停止开发），若商店打不开的话可以直接下载Github上面的crx文件可参考该扩展提供的图解流程。 直接参考 SwitchySharp+shadowsocks-nodejs Windows 下配置介绍 的第二部分”设置浏览器代理扩展“即可。或者参考我的配置@2015.02.04文件即可，支持自动通过gfwlist自动切换。 最后，加一个链接，你懂的 https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt 2016-06-24 上面的链接貌似不能用了。加一个 https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt https://github.com/gfwlist/gfwlist 引用地址：https://wiki.archlinux.org/index.php/Shadowsocks_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deban安装composer]]></title>
    <url>%2F2015%2F07%2F22%2F2015-2015-07-22-debian-install-composer%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 常用方式 - cd /usr/local/bin - curl -sS https://getcomposer.org/installer | php 完成后，当前文件夹就会多出一个 composer.phar ，重命名为 composer mv composer.phar composer - chmod a+x composer - composer self-update 安装一些常用的全局的工具 #phpunit composer global require &apos;phpunit/phpunit&apos; #php-cs-fixer #composer global require &apos;fabpot/php-cs-fixer:dev-master&apos; #上面那个是老版本，改成下面那个了 composer global require &apos;friendsofphp/php-cs-fixer:dev-master&apos; 优雅方式本方式引用自 http://blog.csdn.net/meegomeego/article/details/38984051 随便一个文件夹下载composer.phar , 比如 ~/ cd ~ &amp;&amp; curl -sS https://getcomposer.org/installer | php 安装各类 global 工具，包括composer自己也是可以用composer来安装的 ./composer.phar global require &apos;composer/composer:dev-master&apos; ./composer.phar global require &apos;phpunit/phpunit:3.7.*&apos; ./composer.phar global require &apos;fabpot/php-cs-fixer:dev-master&apos; 将 vendor/bin 添加到你的PATH变量里 本方式引用至 http://blog.csdn.net/meegomeego/article/details/38984051 原文中bin目录为 ~/.composer/vendor/bin 本人的bin目录为 ~/.config/composer/vendor/bin 可能是系统不同的原因（本人用的debian jessie）或者是composer版本等原因 self-update 方法 貌似没有找到。哈哈哈哈]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>debian</tag>
        <tag>php</tag>
        <tag>composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debian 修改时区]]></title>
    <url>%2F2015%2F06%2F18%2F2015-2015-06-18-debian-set-timezone%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 配置时区的命令是： dpkg-reconfigure tzdata 运行后选择要修改的时区对应的编号，如选Asia时，在Geographic area: 填6 debconf: unable to initialize frontend: Dialog debconf: (No usable dialog-like program is installed, so the dialog based frontend cannot be used. at /usr/share/perl5/Debconf/FrontEnd/Dialog.pm line 76.) debconf: falling back to frontend: Readline Configuring tzdata ------------------ Please select the geographic area in which you live. Subsequent configuration questions will narrow this down by presenting a list of cities, representing the time zones in which they are located. 1. Africa 2. America 3. Antarctica 4. Australia 5. Arctic Ocean 6. Asia 7. Atlantic Ocean 8. Europe 9. Indian Ocean 10. Pacific Ocean 11. System V timezones 12. US 13. None of the above Geographic area: 6 选择后Asia后， Please select the city or region corresponding to your time zone. 1. Aden 8. Baghdad 15. Chita 22. Dubai 29. Hovd 36. Kamchatka 43. Kuala_Lumpur 50. Muscat 57. Pontianak 64. Samarkand 71. Tbilisi 78. Urumqi 2. Almaty 9. Bahrain 16. Choibalsan 23. Dushanbe 30. Irkutsk 37. Karachi 44. Kuching 51. Nicosia 58. Pyongyang 65. Seoul 72. Tehran 79. Ust-Nera 3. Amman 10. Baku 17. Chongqing 24. Gaza 31. Istanbul 38. Kashgar 45. Kuwait 52. Novokuznetsk 59. Qatar 66. Shanghai 73. Tel_Aviv 80. Vientiane 4. Anadyr 11. Bangkok 18. Colombo 25. Harbin 32. Jakarta 39. Kathmandu 46. Macau 53. Novosibirsk 60. Qyzylorda 67. Singapore 74. Thimphu 81. Vladivostok 5. Aqtau 12. Beirut 19. Damascus 26. Hebron 33. Jayapura 40. Khandyga 47. Magadan 54. Omsk 61. Rangoon 68. Srednekolymsk 75. Tokyo 82. Yakutsk 6. Aqtobe 13. Bishkek 20. Dhaka 27. Ho_Chi_Minh 34. Jerusalem 41. Kolkata 48. Makassar 55. Oral 62. Riyadh 69. Taipei 76. Ujung_Pandang 83. Yekaterinburg 7. Ashgabat 14. Brunei 21. Dili 28. Hong_Kong 35. Kabul 42. Krasnoyarsk 49. Manila 56. Phnom_Penh 63. Sakhalin 70. Tashkent 77. Ulaanbaatar 84. Yerevan Time zone: 66 选上海则选66 Current default time zone: &apos;Asia/Shanghai&apos; Local time is now: Fri Oct 16 11:20:19 CST 2015. Universal Time is now: Fri Oct 16 03:20:19 UTC 2015. 设置成功]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>debian</tag>
        <tag>timezone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式\w并不完全等于[A-Za-z0-9]]]></title>
    <url>%2F2015%2F05%2F29%2F2015-2015-05-29-zhengzebug%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 不管是书本上还是网上的教程,在正则表达式中\w都被介绍为匹配任何单词字符,包括字母和下划线，等效于[A-Za-z0-9] 今天偶然间发现会员注册中出现了一个恶作剧账号”аdmin”,注意到那个а了没?那是一个俄文字母,在会员注册过滤中使用\w验证并不能防止。 也就是说\w包括了英文字母以及俄文字母等，在会员注册这块我们肯定不希望类同的账号出现，要不然很容易造成会员间的误会。 所以改为^[A-Za-z0-9\u4E00-\u9FA5-]{2,16}$验证，只允许数字、26个英文字母大小写、中文及其组合。 通过网络检测发现，目前的大部分网站账号基本有此误检测的BUG，DZ的不论PHP还是net版均存在此问题。 想象一下吧，一个网站已存存在一个英文会员账号“admin”，再出现一个俄文或俄文英文混合的账号，如“аdmin”，够混乱吧？]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>preg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysqli的参数化查询，学习一下，马上就用]]></title>
    <url>%2F2015%2F05%2F26%2F2015-2015-05-26-mysqli-learn%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 $db = new mysqli(“localhost”, “user”, “pass”, “database”); $stmt = $mysqli -&gt; prepare(“SELECT priv FROM testUsers WHERE username=? AND password=?”); $stmt -&gt; bind_param(“ss”, $user, $pass); $stmt -&gt; execute(); 以这个为基础，封装成类]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>mysqli</tag>
        <tag>参数化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的debian常用apt源]]></title>
    <url>%2F2015%2F05%2F19%2F2015-2015-05-19-debian-apt-source%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 deb http://mirrors.aliyun.com/debian jessie main non-free contrib deb-src http://mirrors.aliyun.com/debian jessie main non-free contrib deb http://mirrors.aliyun.com/debian jessie-updates main non-free contrib deb-src http://mirrors.aliyun.com/debian jessie-updates main non-free contrib url中的aliyun可以改成163等；]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>debian</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux中iptables设置详细]]></title>
    <url>%2F2015%2F03%2F29%2F2015-2015-03-29-linux-iptables-setup%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 无论如何，iptables是一个需要特别谨慎设置的东西，万一服务器不在你身边，而你贸然设置导致无法SSH，那就等着被老板骂吧，呵呵。。。 一下内容是为了防止这种情况发生而写的，当然很初级，不过一般服务器也够用了： 1.首先介绍一下指令和相关配置文件 启动指令:service iptables start 重启指令:service iptables restart 关闭指令:service iptables stop 然后是相关配置:/etc/sysconfig/iptables 如何操作该配置呢？ vim /etc/sysconfig/iptables 然后进去修改即可，修改完了怎么办？这里很多人会想到/etc/rc.d/init.d/iptables save指令，但是一旦你这么干了你刚才的修改内容就白做了。。。 具体方法是： 只修改/etc/sysconfig/iptables 使其生效的办法是修改好后先service iptables restart，然后才调用/etc/rc.d/init.d/iptables save，因为/etc/rc.d/init.d/iptables save会在iptables服务启动时重新加载，要是在重启之前直接先调用了/etc/rc.d/init.d/iptables save那么你的/etc/sysconfig/iptables 配置就回滚到上次启动服务的配置了，这点必须注意！！！ 2.下面介绍一些指令用法（主要还是man iptables看下相关资料才行） -A：指定链名 -p：指定协议类型 -d：指定目标地址 –dport：指定目标端口（destination port 目的端口） –sport：指定源端口（source port 源端口） -j：指定动作类型 3.如果我不像修改文件直接打命令可以吗，当然没问题，步骤如下: 例如我给SSH加放行的语句： 添加input记录： iptables -A INPUT -p tcp –dport 22 -j ACCEPT 添加output记录： iptables -A OUTPUT -p tcp –sport 22 -j ACCEPT 最后注意需要再执行一下 /etc/init.d/iptables save，这样这两条语句就保存到刚才那个/etc/sysconfig/iptables 文件中了。 4.接下来说明一下步骤，如果机器不在我身边，我只能SSH进去做iptables规则，那么我必须注意每一步，千万别搞错了，否则就SSH链接不上都有可能！ 首先要做的是给咱的SSH进行ACCEPT配置，以免直接无法连接的情况发生: 1.如果SSH端口是22（这里不建议用默认端口最好改掉SSH端口） iptables -A INPUT -p tcp –dport 22 -j ACCEPT iptables -A OUTPUT -p tcp –sport 22 -j ACCEPT 注意要/etc/rc.d/init.d/iptables save，以下每一步都最好执行一遍此语句，以下不再累述。 2.vim /etc/sysconfig/iptables确定是否已经加入配置，可以的话执行service iptables restart重启后生效 3.下面是很危险的操作，如果你第一步没做就会直接可能导致你连不上SSH，此步骤前切记执行第一步！！！ iptables -P INPUT DROP iptables -P OUTPUT DROP iptables -P FORWARD DROP 这个步骤是把所有不符合自己配置的规则ACCEPT的连接全部DROP掉，执行完以后如果咱SSH还没掉，那么谢天谢地，安全了，重启下iptables后继续下面的配置！ 4.下面咱就不细说了，具体就是看自己服务器要开放哪些端口或者是要访问哪些端口来做具体的配置，下面是我自己的机器的配置： /etc/sysconfig/iptables文件配置如下: #Generated by iptables-save v1.4.7 on Fri Mar 2 19:59:43 2012 *filter :INPUT DROP [0:0] :FORWARD DROP [0:0] :OUTPUT DROP [8:496] -A INPUT -m state –state RELATED,ESTABLISHED -j ACCEPT #ping使用的端口 -A INPUT -p icmp -j ACCEPT -A INPUT -i lo -j ACCEPT -A INPUT -s 127.0.0.1/32 -d 127.0.0.1/32 -j ACCEPT -A INPUT -s 192.168.2.200/32 -d 192.168.2.200/32 -j ACCEPT #允许服务器自己的SSH（对外部请求来说服务器是目标所以使用–dport） -A INPUT -p tcp -m tcp –dport 22 -j ACCEPT #80端口不用说了吧，服务器网站访问端口 -A INPUT -p tcp -m tcp –dport 80 -j ACCEPT -A INPUT -p tcp -m tcp –dport 3306 -j ACCEPT -A INPUT -p tcp -m tcp –dport 11211 -j ACCEPT -A INPUT -p tcp -m tcp –dport 11212 -j ACCEPT -A FORWARD -j REJECT –reject-with icmp-host-prohibited #53端口是DNS相关，TCP和UDP都要配置 -A INPUT -p tcp -m tcp –dport 53 -j ACCEPT -A INPUT -p udp -m udp –dport 53 -j ACCEPT #ping使用的端口 -A OUTPUT -p icmp -j ACCEPT -A OUTPUT -s 127.0.0.1/32 -d 127.0.0.1/32 -j ACCEPT -A OUTPUT -s 192.168.2.200/32 -d 192.168.2.200/32 -j ACCEPT #允许服务器SSH到其他机器（使用外部端口就使用–dport） -A OUTPUT -p tcp -m tcp –dport 22 -j ACCEPT #允许服务器自己的SSH（自已为源输出就使用–sport） -A OUTPUT -p tcp -m tcp –sport 22 -j ACCEPT #访问外部网站80端口（使用外部端口就使用–dport） -A OUTPUT -p tcp -m tcp –dport 80 -j ACCEPT #如果服务器需要访问外部网站，那么OUTPUT也需要配置53端口（使用外部端口就使用–dport） -A OUTPUT -p tcp -m tcp –dport 53 -j ACCEPT -A OUTPUT -p udp -m udp –dport 53 -j ACCEPT #如果有访问外部邮箱，那么打开邮箱相关端口（使用外部端口就使用–dport） -A OUTPUT -p tcp -m tcp –dport 465 -j ACCEPT -A OUTPUT -p tcp -m tcp –dport 25 -j ACCEPT -A OUTPUT -p tcp -m tcp –dport 110 -j ACCEPT #服务器网站访问端口（自已为源输出就使用–sport） -A OUTPUT -p tcp -m tcp –sport 80 -j ACCEPT -A OUTPUT -p tcp -m tcp –sport 3306 -j ACCEPT -A OUTPUT -p tcp -m tcp –sport 11211 -j ACCEPT -A OUTPUT -p tcp -m tcp –sport 11212 -j ACCEPT COMMIT Completed on Fri Mar 2 19:59:43 2012 5.可能有时候需要删除规则，最简单就是修改一下/etc/sysconfig/iptables然后service iptables restart,最后/etc/rc.d/init.d/iptables save即可。 当然也可以使用指令完成: 在网上找了一下，删除规则的方法： 语法是： iptables -D chain rulenum [options] 其中： chain 是链的意思，就是INPUT FORWARD 之类的 rulenum 是规则的编号。从1 开始。可以使用 –line-numbers 列出规则的编号 所以，例如上面要删除一个INPUT链的规则的话可以这样： iptables -D INPUT 3 意思是删除第3条规则。 还有第二种方法。第二种办法是 -A 命令的映射，不过用-D替换-A。当你的链中规则很复杂，而你不想计算它们的编号的时候这就十分有用了。也就是说，你如何用iptables -A…. 语句定义了一个规则，则删除此规则时就用 -D 来代替- A 其余的都不变即可。 ====================== 说一下上面的 –line-numbers 选项，如下面的命令： iptables -L INPUT --line-numbers 列出INPUT 链所有的规则 num target prot opt source destination 1 REJECT tcp – anywhere anywhere tcp dpt:microsoft-ds reject-with icmp-port-unreachable 2 REJECT tcp – anywhere anywhere tcp dpt:135 reject-with icmp-port-unreachable 3 REJECT tcp – anywhere anywhere tcp dpt:netbios-ssn reject-with icmp-port-unreachable … … 删除指定行规则： [root@localhost rc.d]# iptables -D INPUT 4 6.最后补充一下，如果想针对某IP进行单独开放端口可以如下配置： 如果我需要对内网某机器单独开放mysql端口，应该如下配置： iptables -A INPUT -s 192.168.2.6 -p tcp -m tcp --dport 3306 -j ACCEPT iptables -A OUTPUT -s 192.168.2.6 -p tcp -m tcp --sport 3306 -j ACCEPT 7.彻底禁止某IP访问: #屏蔽单个IP的命令是 iptables -I INPUT -s 123.45.6.7 -j DROP #封整个段即从123.0.0.1到123.255.255.254的命令 iptables -I INPUT -s 123.0.0.0/8 -j DROP #封IP段即从123.45.0.1到123.45.255.254的命令 iptables -I INPUT -s 124.45.0.0/16 -j DROP #封IP段即从123.45.6.1到123.45.6.254的命令是 iptables -I INPUT -s 123.45.6.0/24 -j DROP 指令I是insert指令 但是该指令会insert在正确位置并不像A指令看你自己的排序位置，因此用屏蔽因为必须在一开始就要加载屏蔽IP，所以必须使用I命令加载，然后注意执行/etc/rc.d/init.d/iptables save进行保存后重启服务即可]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql更新多条数据不建议使用UPDATE语句]]></title>
    <url>%2F2015%2F03%2F20%2F2015-2015-03-20-mysql-updateupdate%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 我们知道当插入多条数据的时候insert支持多条语句： INSERT INTO t_member (id, name, email) VALUES (1, &apos;nick&apos;, &apos;nick@126.com&apos;),(4, &apos;angel&apos;,&apos;angel@163.com&apos;),(7, &apos;brank&apos;,&apos;ba198@126.com&apos;); 但是对于更新记录，由于update语法不支持一次更新多条记录，只能一条一条执行： UPDATE t_member SET name=&apos;nick&apos;, email=&apos;nick@126.com&apos; WHERE id=1; UPDATE t_member SET name=&apos;angel&apos;, email=&apos;angel@163.com&apos; WHERE id=4; UPDATE t_member SET name=&apos;brank&apos;, email=&apos;ba198@126.com&apos; WHERE id=7; 这里问题就出现了，倘若这个update list非常大时(譬如说5000条)，这个执行率可想而知。 这就要介绍一下在MySql中INSERT语法具有一个条件DUPLICATE KEY UPDATE，这个语法和适合用在需要判断记录是否存在，不存在则插入存在则更新的记录。 具体的语法可以参见：http://dev.mysql.com/doc/refman/5.0/en/insert.html 基于上面这种情况，针对更新记录，仍然使用insert语句，不过限制主键重复时，更新字段。如下： INSERT INTO t_member (id, name, email) VALUES (1, &apos;nick&apos;, &apos;nick@126.com&apos;),(4, &apos;angel&apos;,&apos;angel@163.com&apos;),(7, &apos;brank&apos;,&apos;ba198@126.com&apos;) ON DUPLICATE KEY UPDATE name=VALUES(name), email=VALUES(email); 注意：ON DUPLICATE KEY UPDATE只是MySQL的特有语法，并不是SQL标准语法！]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jekyll bootstrap 的搭建]]></title>
    <url>%2F2015%2F02%2F20%2F2015-2015-02-20-jekyll-bootstrap-start-config%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 1、update ，你懂的sudo apt-get update 2、安装 gemsudo apt-get install gem 3、jekyll 依赖 ruby，so 安装之sudo apt-get install ruby-full build-essential 4、安装 jekyll 等各项工具gem install jekyll 5、sudo gem install bundler 6、sudo gem install jekyll-sitemap 7、sudo gem install pygments.rb 8、进入项目文件夹，启动服务cd USERNAME.github.com jekyll serve 9、一般项目根目录里面有 Gemfile 和 Gemfile.lock 文件，这是依赖，和composer类似# install gems required 直接运行 bundle install 10、如果 jekyll serve 无法启动，则可以用bundle exec COMMAND 来执行，一般是依赖的版本不对引起的bundle exec jekyll serve end参考资料 https://www.rosehosting.com/blog/how-to-install-jekyll-on-debian-8/ https://github.com/jekyll/jekyll/issues/4972 http://stackoverflow.com/questions/19061774/cannot-load-such-file-bundler-setup-loaderror http://jekyllbootstrap.com/usage/jekyll-quick-start.html]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>jekyll</tag>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debian 安装fcitx五笔拼音]]></title>
    <url>%2F2015%2F02%2F20%2F2015-2015-02-20-debian-install-fcitx-wubi%2F</url>
    <content type="text"><![CDATA[从前blog移植过来，暂无摘要，后期再补 更新本地软件包索引，并安装fcitx输入法框架以及fcitx五笔拼音输入法sudo apt-get update sudo apt-get install fcitx fcitx-table-wbpy fcitx-config-gtk 配置fcitx五笔拼音输入法上面的 apt-get install命令完成后，重新登录系统，这样是为了检测新安装的输入法。然后以普通用户在终端里输入下面的命令打开fcitx输入法配置窗口。 fcitx-config-gtk3 在安装fcitx五笔拼音的同时也会安装拼音和双拼输入法，所以如果你只想要五笔拼音，那么可以在这个配置窗口里将拼音和双拼删除，保留键盘布局和五笔拼音输入法 将拼音和双拼删除后，你就可以用Ctrl+空格键来调出fcitx五笔拼音输入法了。既可以打五笔，又可以打拼音。打拼音的同时还会教你五笔怎么打，非常方便。 Telegram不能使用fcitx输入中文的解决办法解决的方法很简单。打开home目录下的.bashrc文件。 vim ~/.bashrc 将下面的三行命令添加到文件末尾。bashrc文件里的命令会在每次用户登录的时候执行。 export GTK_IM_MODULE=fcitx export XMODIFIERS=@im=fcitx export QT_IM_MODULE=fcitx 保存文件后重新登录系统。现在就可以在telegram里用fcitx输入中文了。]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>debian</tag>
        <tag>fcitx</tag>
        <tag>wubi</tag>
      </tags>
  </entry>
</search>
